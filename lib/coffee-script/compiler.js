// Generated by CoffeeScript 1.3.3
var CS, JS, beingDeclared, concatMap, envEnrichments, exports, expr, jsReserved, makeReturn, map, statementNodes, stmt, union, usedAsExpression, _ref, _ref1, _ref2,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./functional-helpers'), concatMap = _ref.concatMap, map = _ref.map, union = _ref.union;

_ref1 = require('./helpers'), beingDeclared = _ref1.beingDeclared, usedAsExpression = _ref1.usedAsExpression, envEnrichments = _ref1.envEnrichments;

CS = require('./nodes');

JS = require('./js-nodes');

exports = (_ref2 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref2 : this;

jsReserved = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield'];

statementNodes = [JS.BlockStatement, JS.BreakStatement, JS.ContinueStatement, JS.DebuggerStatement, JS.DoWhileStatement, JS.EmptyStatement, JS.ExpressionStatement, JS.ForInStatement, JS.ForStatement, JS.FunctionDeclaration, JS.IfStatement, JS.LabeledStatement, JS.ReturnStatement, JS.SwitchStatement, JS.ThrowStatement, JS.TryStatement, JS.VariableDeclaration, JS.WhileStatement, JS.WithStatement];

makeReturn = function(node) {
  if (node["instanceof"](JS.BlockStatement)) {
    return new JS.BlockStatement(__slice.call(node.body.slice(0, -1)).concat([new JS.ReturnStatement(expr(node.body[node.body.length - 1]))]));
  } else {
    return new JS.ReturnStatement(expr(node));
  }
};

stmt = function(e) {
  var walk;
  if (e == null) {
    return e;
  }
  if (e["instanceof"].apply(e, statementNodes)) {
    return e;
  } else if (e["instanceof"](JS.SequenceExpression)) {
    walk = function(seq) {
      return concatMap(seq.expressions, function(e) {
        if (e["instanceof"](JS.SequenceExpression)) {
          return walk(e);
        } else {
          return [stmt(e)];
        }
      });
    };
    return new JS.BlockStatement(walk(e));
  } else if (e["instanceof"](JS.ConditionalExpression)) {
    return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
  } else {
    return new JS.ExpressionStatement(e);
  }
};

expr = function(s) {
  var alternate, consequent, _ref3, _ref4;
  if (s == null) {
    return s;
  }
  if (!s["instanceof"].apply(s, statementNodes)) {
    return s;
  } else if (s["instanceof"](JS.BlockStatement)) {
    return new JS.SequenceExpression(s.body);
  } else if (s["instanceof"](JS.BreakStatement)) {

  } else if (s["instanceof"](JS.ExpressionStatement)) {
    return s.expression;
  } else if (s["instanceof"](JS.IfStatement)) {
    consequent = expr((_ref3 = s.consequent) != null ? _ref3 : new JS.UnaryExpression('void', new JS.Literal(0)));
    alternate = expr((_ref4 = s.alternate) != null ? _ref4 : new JS.UnaryExpression('void', new JS.Literal(0)));
    return new JS.ConditionalExpression(s.test, consequent, alternate);
  } else {
    throw new Error("expr: " + s.type);
  }
};

exports.Compiler = (function() {
  var defaultRules;

  defaultRules = [
    [
      CS.Program, function(_arg) {
        var block;
        block = _arg.block;
        if (block == null) {
          return new JS.Program([]);
        }
        block = stmt(block);
        block = block["instanceof"](JS.BlockStatement) ? block.body : [block];
        return new JS.Program(block);
      }
    ], [
      CS.Block, function(_arg) {
        var statements;
        statements = _arg.statements;
        switch (statements.length) {
          case 0:
            return new JS.EmptyStatement;
          case 1:
            return new stmt(statements[0]);
          default:
            return new JS.BlockStatement(map(statements, stmt));
        }
      }
    ], [
      CS.SeqOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.SequenceExpression([left, right]);
      }
    ], [
      CS.Conditional, function(_arg) {
        var block, compile, condition, elseBlock;
        condition = _arg.condition, block = _arg.block, elseBlock = _arg.elseBlock, compile = _arg.compile;
        return new JS.IfStatement(expr(condition), stmt(block), stmt(elseBlock));
      }
    ], [
      CS.ArrayInitialiser, function(_arg) {
        var members;
        members = _arg.members;
        return new JS.ArrayExpression(map(members, expr));
      }
    ], [
      CS.Function, function(_arg) {
        var block, parameters;
        parameters = _arg.parameters, block = _arg.block;
        block = makeReturn(stmt(block));
        if (!block["instanceof"](JS.BlockStatement)) {
          block = new JS.BlockStatement([block]);
        }
        return new JS.FunctionExpression(null, parameters, block);
      }
    ], [
      CS.FunctionApplication, function(_arg) {
        var args, fn;
        fn = _arg["function"], args = _arg["arguments"];
        return new JS.CallExpression(expr(fn), map(args, expr));
      }
    ], [
      CS.NewOp, function(_arg) {
        var args, constructor;
        constructor = _arg.constructor, args = _arg["arguments"];
        return new JS.NewExpression(constructor, args);
      }
    ], [
      CS.MemberAccessOp, function(_arg) {
        var expression, memberAccess, _ref3;
        expression = _arg.expression;
        if (_ref3 = this.memberName, __indexOf.call(jsReserved, _ref3) >= 0) {
          memberAccess = new JS.MemberExpression(expression, new JS.Literal(this.memberName));
          memberAccess.computed = true;
          return memberAccess;
        } else {
          return new JS.MemberExpression(expression, new JS.Identifier(this.memberName));
        }
      }
    ], [
      CS.UnaryExistsOp, function(_arg) {
        var compile, expression, inScope, nullTest, typeofTest, _ref3;
        expression = _arg.expression, inScope = _arg.inScope, compile = _arg.compile;
        nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
        if ((expression["instanceof"](JS.Identifier)) && (_ref3 = expression.name, __indexOf.call(inScope, _ref3) < 0)) {
          typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
          return new JS.BinaryExpression('&&', typeofTest, nullTest);
        } else {
          return nullTest;
        }
      }
    ], [
      CS.DoOp, function(_arg) {
        var args, compile, expression, param;
        expression = _arg.expression, compile = _arg.compile;
        args = [];
        if (this.expression["instanceof"](CS.Function)) {
          args = (function() {
            var _i, _len, _ref3, _results;
            _ref3 = this.expression.parameters;
            _results = [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              param = _ref3[_i];
              switch (false) {
                case !param["instanceof"](CS.AssignOp):
                  _results.push(param.expression);
                  break;
                case !param["instanceof"](CS.Identifier, CS.MemberAccessOp):
                  _results.push(param);
                  break;
                default:
                  _results.push((new CS.Undefined).g());
              }
            }
            return _results;
          }).call(this);
        }
        return compile(new CS.FunctionApplication(this.expression, args));
      }
    ], [
      CS.DivideOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('/', expr(left), expr(right));
      }
    ], [
      CS.MultiplyOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('*', expr(left), expr(right));
      }
    ], [
      CS.RemOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('%', expr(left), expr(right));
      }
    ], [
      CS.PlusOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('+', expr(left), expr(right));
      }
    ], [
      CS.SubtractOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('-', expr(left), expr(right));
      }
    ], [
      CS.OfOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('in', expr(left), expr(right));
      }
    ], [
      CS.InstanceofOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('instanceof', expr(left), expr(right));
      }
    ], [
      CS.LogicalAndOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('&&', expr(left), expr(right));
      }
    ], [
      CS.LogicalOrOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('||', expr(left), expr(right));
      }
    ], [
      CS.EQOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('===', expr(left), expr(right));
      }
    ], [
      CS.NEQOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('!==', expr(left), expr(right));
      }
    ], [
      CS.GTEOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>=', expr(left), expr(right));
      }
    ], [
      CS.GTOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>', expr(left), expr(right));
      }
    ], [
      CS.LTEOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<=', expr(left), expr(right));
      }
    ], [
      CS.LTOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<', expr(left), expr(right));
      }
    ], [
      CS.BitAndOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('&', expr(left), expr(right));
      }
    ], [
      CS.BitOrOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('|', expr(left), expr(right));
      }
    ], [
      CS.BitXorOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('^', expr(left), expr(right));
      }
    ], [
      CS.LeftShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<<', expr(left), expr(right));
      }
    ], [
      CS.SignedRightShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>>', expr(left), expr(right));
      }
    ], [
      CS.UnsignedRightShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>>>', expr(left), expr(right));
      }
    ], [
      CS.Identifier, function() {
        return new JS.Identifier(this.data);
      }
    ], [
      CS.Bool, CS.Int, CS.Float, CS.String, function() {
        return new JS.Literal(this.data);
      }
    ], [
      CS.Null, function() {
        return new JS.Literal(null);
      }
    ], [
      CS.Undefined, function() {
        return new JS.UnaryExpression('void', new JS.Literal(0));
      }
    ], [
      CS.This, function() {
        return new JS.ThisExpression;
      }
    ]
  ];

  function Compiler() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref3;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref3 = defaultRules[_i], ctors = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), handler = _ref3[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Compiler.prototype.addRule = function(ctor, handler) {
    this.rules[ctor] = handler;
    return this;
  };

  Compiler.prototype.compile = (function() {
    var defaultRule, walk;
    walk = function(fn, inScope, ancestry) {
      var child, childName, children, jsNode, member, _i, _len, _ref3, _ref4;
      if (inScope == null) {
        inScope = [];
      }
      if (ancestry == null) {
        ancestry = [];
      }
      if (((_ref3 = ancestry[0]) != null ? _ref3["instanceof"](CS.Function, CS.BoundFunction) : void 0) && this === ancestry[0].block) {
        inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
      }
      ancestry.unshift(this);
      children = {};
      _ref4 = this.childNodes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        childName = _ref4[_i];
        if (this[childName] != null) {
          children[childName] = (function() {
            var _j, _len1, _ref5, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref5 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
                member = _ref5[_j];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(jsNode);
              }
              return _results;
            } else {
              child = this[childName];
              jsNode = walk.call(child, fn, inScope, ancestry);
              inScope = union(inScope, envEnrichments(child, inScope));
              return jsNode;
            }
          }).call(this);
        }
      }
      children.inScope = inScope;
      children.ancestry = ancestry;
      children.compile = function(node) {
        return walk.call(node.g(), fn, inScope, ancestry);
      };
      ancestry.shift();
      return fn.call(this, children);
    };
    defaultRule = function() {
      throw new Error("compile: Non-exhaustive patterns in case: " + this.className);
    };
    return function(ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function() {
        var _ref3;
        return ((_ref3 = rules[this.className]) != null ? _ref3 : defaultRule).apply(this, arguments);
      });
    };
  })();

  return Compiler;

})();
