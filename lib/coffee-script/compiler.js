// Generated by CoffeeScript 1.3.3
var CS, JS, concatMap, envEnrichments, exports, map, seqToBlock, statementNodes, toStatement, union, usedAsExpression, _ref, _ref1, _ref2,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./functional-helpers'), concatMap = _ref.concatMap, map = _ref.map, union = _ref.union;

_ref1 = require('./helpers'), usedAsExpression = _ref1.usedAsExpression, envEnrichments = _ref1.envEnrichments;

CS = require('./nodes');

JS = require('./js-nodes');

exports = (_ref2 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref2 : this;

statementNodes = [JS.BlockStatement, JS.BreakStatement, JS.ContinueStatement, JS.DoWhileStatement, JS.DebuggerStatement, JS.EmptyStatement, JS.ExpressionStatement, JS.ForStatement, JS.ForInStatement, JS.FunctionDeclaration, JS.LabeledStatement, JS.ReturnStatement, JS.SwitchStatement, JS.ThrowStatement, JS.TryStatement, JS.VariableDeclaration, JS.WhileStatement, JS.WithStatement];

toStatement = function(node) {
  if (node["instanceof"].apply(node, statementNodes)) {
    return node;
  } else {
    return new JS.ExpressionStatement(node);
  }
};

seqToBlock = function(seq) {
  var walk;
  walk = function(seq) {
    return concatMap(seq.expressions, function(e) {
      if (e["instanceof"](JS.SequenceExpression)) {
        return walk(e);
      } else {
        return [new JS.ExpressionStatement(e)];
      }
    });
  };
  return new JS.BlockStatement(walk(seq));
};

exports.Compiler = (function() {
  var defaultRules;

  defaultRules = [
    [
      CS.Program, function(_arg) {
        var block;
        block = _arg.block;
        block = !(block != null) ? [] : block["instanceof"](JS.SequenceExpression) ? seq.expressions : block["instanceof"](JS.BlockStatement) ? block.body : [toStatement(block)];
        return new JS.Program(block);
      }
    ], [
      CS.Block, function(_arg) {
        var statements;
        statements = _arg.statements;
        switch (statements.length) {
          case 0:
            return new JS.EmptyStatement;
          case 1:
            return new JS.ExpressionStatement(statements[0]);
          default:
            return new JS.BlockStatement(map(statements, function(s) {
              return new JS.ExpressionStatement(s);
            }));
        }
      }
    ], [
      CS.Function, function(_arg) {
        var block, parameters;
        parameters = _arg.parameters, block = _arg.block;
        if (block["instanceof"](JS.SequenceExpression)) {
          block = seqToBlock(block);
        }
        if (block["instanceof"](JS.BlockStatement)) {
          block.body[block.body.length - 1] = new JS.ReturnStatement(block.body[block.body.length - 1].expression);
        } else {
          block = new JS.BlockStatement([new JS.ReturnStatement(block)]);
        }
        return new JS.FunctionExpression(null, parameters, block);
      }
    ], [
      CS.SeqOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.SequenceExpression([left, right]);
      }
    ], [
      CS.FunctionApplication, function(_arg) {
        var args, fn;
        fn = _arg["function"], args = _arg["arguments"];
        return new JS.CallExpression(fn, args);
      }
    ], [
      CS.Identifier, function() {
        return new JS.Identifier(this.data);
      }
    ], [
      CS.Bool, CS.Int, CS.Float, CS.String, function() {
        return new JS.Literal(this.data);
      }
    ], [
      CS.Null, function() {
        return new JS.Literal(null);
      }
    ], [
      CS.This, function() {
        return new JS.ThisExpression;
      }
    ]
  ];

  function Compiler() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref3;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref3 = defaultRules[_i], ctors = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), handler = _ref3[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Compiler.prototype.addRule = function(ctor, handler) {
    this.rules[ctor] = handler;
    return this;
  };

  Compiler.prototype.compile = (function() {
    var defaultRule, walk;
    walk = function(fn, inScope, ancestry) {
      var child, childName, children, jsNode, member, _i, _len, _ref3;
      if (inScope == null) {
        inScope = [];
      }
      if (ancestry == null) {
        ancestry = [];
      }
      ancestry.unshift(this);
      children = {};
      _ref3 = this.childNodes;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        childName = _ref3[_i];
        if (this[childName] != null) {
          children[childName] = (function() {
            var _j, _len1, _ref4, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref4 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                member = _ref4[_j];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(jsNode);
              }
              return _results;
            } else {
              child = this[childName];
              jsNode = walk.call(child, fn, inScope, ancestry);
              inScope = union(inScope, envEnrichments(child, inScope));
              return jsNode;
            }
          }).call(this);
        }
      }
      ancestry.shift();
      children.inScope = inScope;
      children.ancestry = ancestry;
      return fn.call(this, children);
    };
    defaultRule = function() {
      throw new Error("compile: Non-exhaustive patterns in case: " + this.className);
    };
    return function(ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function() {
        var _ref3;
        return ((_ref3 = rules[this.className]) != null ? _ref3 : defaultRule).apply(this, arguments);
      });
    };
  })();

  return Compiler;

})();
