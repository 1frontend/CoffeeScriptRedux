// Generated by CoffeeScript 1.3.3
var CS, JS, exports, usedAsExpression, _ref,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

require('./functional-helpers');

usedAsExpression = require('./helpers').usedAsExpression;

CS = require('./nodes');

JS = require('./js-nodes');

exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : this;

exports.Compiler = (function() {
  var defaultRules;

  defaultRules = [
    [
      CS.Identifier, function() {
        return new JS.Identifier(this.data);
      }
    ], [
      CS.Int, function() {
        return new JS.Literal(this.data.toString(10));
      }
    ]
  ];

  function Compiler() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref1;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref1 = defaultRules[_i], ctors = 2 <= _ref1.length ? __slice.call(_ref1, 0, _j = _ref1.length - 1) : (_j = 0, []), handler = _ref1[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Compiler.prototype.addRule = function(ctor, handler) {
    this.rules[ctor] = handler;
    return this;
  };

  Compiler.prototype.compile = (function() {
    var defaultRule, walk;
    walk = function(fn, inScope, ancestry) {
      var child, childName, children, jsNode, member, _i, _len, _ref1;
      if (inScope == null) {
        inScope = [];
      }
      if (ancestry == null) {
        ancestry = [];
      }
      ancestry.unshift(this);
      children = {};
      _ref1 = this.childNodes;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        childName = _ref1[_i];
        if (this[childName] != null) {
          children[childName] = (function() {
            var _j, _len1, _ref2, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref2 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                member = _ref2[_j];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(jsNode);
              }
              return _results;
            } else {
              child = this[childName];
              jsNode = walk.call(child, fn, inScope, ancestry);
              inScope = union(inScope, envEnrichments(child, inScope));
              return this[childName] = child;
            }
          }).call(this);
        }
      }
      ancestry.shift();
      children.inScope = children;
      children.ancestry = ancestry;
      return fn.call(this, children);
    };
    defaultRule = function() {
      throw new Error("compile: Non-exhaustive patterns in case: " + this.className);
    };
    return function(ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function() {
        var _ref1;
        return ((_ref1 = rules[this.className]) != null ? _ref1 : defaultRule).apply(this, arguments);
      });
    };
  })();

  return Compiler;

})();
