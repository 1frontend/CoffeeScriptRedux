// Generated by CoffeeScript 1.3.3
var CS, JS, concatMap, envEnrichments, exports, expr, makeReturn, map, statementNodes, stmt, union, usedAsExpression, _ref, _ref1, _ref2,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./functional-helpers'), concatMap = _ref.concatMap, map = _ref.map, union = _ref.union;

_ref1 = require('./helpers'), usedAsExpression = _ref1.usedAsExpression, envEnrichments = _ref1.envEnrichments;

CS = require('./nodes');

JS = require('./js-nodes');

exports = (_ref2 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref2 : this;

statementNodes = [JS.BlockStatement, JS.BreakStatement, JS.ContinueStatement, JS.DoWhileStatement, JS.DebuggerStatement, JS.EmptyStatement, JS.ExpressionStatement, JS.ForStatement, JS.ForInStatement, JS.FunctionDeclaration, JS.IfStatement, JS.LabeledStatement, JS.ReturnStatement, JS.SwitchStatement, JS.ThrowStatement, JS.TryStatement, JS.VariableDeclaration, JS.WhileStatement, JS.WithStatement];

makeReturn = function(node) {
  if (node["instanceof"](JS.BlockStatement)) {
    return new JS.BlockStatement(__slice.call(node.body.slice(0, -1)).concat([new JS.ReturnStatement(expr(node.body[node.body.length - 1]))]));
  } else {
    return new JS.ReturnStatement(expr(node));
  }
};

stmt = function(e) {
  var walk;
  if (e == null) {
    return e;
  }
  if (e["instanceof"].apply(e, statementNodes)) {
    return e;
  } else if (e["instanceof"](JS.SequenceExpression)) {
    walk = function(seq) {
      return concatMap(seq.expressions, function(e) {
        if (e["instanceof"](JS.SequenceExpression)) {
          return walk(e);
        } else {
          return [stmt(e)];
        }
      });
    };
    return new JS.BlockStatement(walk(e));
  } else if ((e["instanceof"](JS.BinaryExpression)) && e.operator === '&&') {
    return new JS.IfStatement(expr(e.left), stmt(e.right));
  } else if (e["instanceof"](JS.ConditionalExpression)) {
    return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternative));
  } else {
    return new JS.ExpressionStatement(e);
  }
};

expr = function(s) {
  if (s == null) {
    return s;
  }
  if (!s["instanceof"].apply(s, statementNodes)) {
    return s;
  } else if (s["instanceof"](JS.BlockStatement)) {
    return new JS.SequenceExpression(s.body);
  } else if (s["instanceof"](JS.BreakStatement)) {

  } else if (s["instanceof"](JS.ExpressionStatement)) {
    return s.expression;
  } else {
    throw new Error("expr: " + s.type);
  }
};

exports.Compiler = (function() {
  var defaultRules;

  defaultRules = [
    [
      CS.Program, function(_arg) {
        var block;
        block = _arg.block;
        if (block == null) {
          return new JS.Program([]);
        }
        block = stmt(block);
        block = block["instanceof"](JS.BlockStatement) ? block.body : [block];
        return new JS.Program(block);
      }
    ], [
      CS.Block, function(_arg) {
        var statements;
        statements = _arg.statements;
        switch (statements.length) {
          case 0:
            return new JS.EmptyStatement;
          case 1:
            return new stmt(statements[0]);
          default:
            return new JS.BlockStatement(map(statements, stmt));
        }
      }
    ], [
      CS.SeqOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.SequenceExpression([left, right]);
      }
    ], [
      CS.Conditional, function(_arg) {
        var block, compile, condition, elseBlock;
        condition = _arg.condition, block = _arg.block, elseBlock = _arg.elseBlock, compile = _arg.compile;
        if (block == null) {
          block = compile(new CS.Undefined);
        }
        if (elseBlock == null) {
          elseBlock = compile(new CS.Undefined);
        }
        return new JS.ConditionalExpression(expr(condition), expr(block), expr(elseBlock));
      }
    ], [
      CS.FunctionApplication, function(_arg) {
        var args, fn;
        fn = _arg["function"], args = _arg["arguments"];
        return new JS.CallExpression(expr(fn), map(args, expr));
      }
    ], [
      CS.ArrayInitialiser, function(_arg) {
        var members;
        members = _arg.members;
        return new JS.ArrayExpression(map(members, expr));
      }
    ], [
      CS.Function, function(_arg) {
        var block, parameters;
        parameters = _arg.parameters, block = _arg.block;
        block = makeReturn(stmt(block));
        if (!block["instanceof"](JS.BlockStatement)) {
          block = new JS.BlockStatement([block]);
        }
        return new JS.FunctionExpression(null, parameters, block);
      }
    ], [
      CS.Identifier, function() {
        return new JS.Identifier(this.data);
      }
    ], [
      CS.Bool, CS.Int, CS.Float, CS.String, function() {
        return new JS.Literal(this.data);
      }
    ], [
      CS.Null, function() {
        return new JS.Literal(null);
      }
    ], [
      CS.Undefined, function() {
        return new JS.UnaryExpression('void', new JS.Literal(0));
      }
    ], [
      CS.This, function() {
        return new JS.ThisExpression;
      }
    ]
  ];

  function Compiler() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref3;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref3 = defaultRules[_i], ctors = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), handler = _ref3[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Compiler.prototype.addRule = function(ctor, handler) {
    this.rules[ctor] = handler;
    return this;
  };

  Compiler.prototype.compile = (function() {
    var defaultRule, walk;
    walk = function(fn, inScope, ancestry) {
      var child, childName, children, jsNode, member, _i, _len, _ref3;
      if (inScope == null) {
        inScope = [];
      }
      if (ancestry == null) {
        ancestry = [];
      }
      ancestry.unshift(this);
      children = {};
      _ref3 = this.childNodes;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        childName = _ref3[_i];
        if (this[childName] != null) {
          children[childName] = (function() {
            var _j, _len1, _ref4, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref4 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                member = _ref4[_j];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(jsNode);
              }
              return _results;
            } else {
              child = this[childName];
              jsNode = walk.call(child, fn, inScope, ancestry);
              inScope = union(inScope, envEnrichments(child, inScope));
              return jsNode;
            }
          }).call(this);
        }
      }
      children.inScope = inScope;
      children.ancestry = ancestry;
      children.compile = function(node) {
        return walk.call(node.g(), fn, inScope, ancestry);
      };
      ancestry.shift();
      return fn.call(this, children);
    };
    defaultRule = function() {
      throw new Error("compile: Non-exhaustive patterns in case: " + this.className);
    };
    return function(ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function() {
        var _ref3;
        return ((_ref3 = rules[this.className]) != null ? _ref3 : defaultRule).apply(this, arguments);
      });
    };
  })();

  return Compiler;

})();
