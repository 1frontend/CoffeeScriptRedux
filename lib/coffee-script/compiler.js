// Generated by CoffeeScript 1.3.3
var CS, JS, any, beingDeclared, collectIdentifiers, concat, concatMap, declarationsNeededFor, difference, enabledHelpers, envEnrichments, exports, expr, fn, foldl1, forceBlock, genSym, h, helperNames, helpers, inlineHelpers, jsReserved, makeReturn, makeVarDeclaration, map, needsCaching, nub, owns, statementNodes, stmt, union, usedAsExpression, _ref, _ref1, _ref2,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

_ref = require('./functional-helpers'), any = _ref.any, concat = _ref.concat, concatMap = _ref.concatMap, difference = _ref.difference, foldl1 = _ref.foldl1, map = _ref.map, nub = _ref.nub, owns = _ref.owns, union = _ref.union;

_ref1 = require('./helpers'), beingDeclared = _ref1.beingDeclared, usedAsExpression = _ref1.usedAsExpression, envEnrichments = _ref1.envEnrichments;

CS = require('./nodes');

JS = require('./js-nodes');

exports = (_ref2 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref2 : this;

jsReserved = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield'];

statementNodes = [JS.BlockStatement, JS.BreakStatement, JS.ContinueStatement, JS.DebuggerStatement, JS.DoWhileStatement, JS.EmptyStatement, JS.ExpressionStatement, JS.ForInStatement, JS.ForStatement, JS.FunctionDeclaration, JS.IfStatement, JS.LabeledStatement, JS.ReturnStatement, JS.SwitchStatement, JS.ThrowStatement, JS.TryStatement, JS.VariableDeclaration, JS.WhileStatement, JS.WithStatement];

genSym = (function() {
  var genSymCounter;
  genSymCounter = 0;
  return function(pre) {
    return new JS.GenSym(pre, ++genSymCounter);
  };
})();

stmt = function(e) {
  var walk;
  if (e == null) {
    return e;
  }
  if (e["instanceof"].apply(e, statementNodes)) {
    return e;
  } else if (e["instanceof"](JS.SequenceExpression)) {
    walk = function(seq) {
      return concatMap(seq.expressions, function(e) {
        if (e["instanceof"](JS.SequenceExpression)) {
          return walk(e);
        } else {
          return [stmt(e)];
        }
      });
    };
    return new JS.BlockStatement(walk(e));
  } else if (e["instanceof"](JS.ConditionalExpression)) {
    return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
  } else {
    return new JS.ExpressionStatement(e);
  }
};

expr = function(s) {
  var accum, alternate, block, consequent, iife, push, _ref3, _ref4;
  if (s == null) {
    return s;
  }
  if (!s["instanceof"].apply(s, statementNodes)) {
    return s;
  } else if (s["instanceof"](JS.BlockStatement)) {
    switch (s.body.length) {
      case 0:
        return helpers.undef();
      case 1:
        return expr(s.body[0]);
      default:
        return new JS.SequenceExpression(map(s.body, expr));
    }
  } else if (s["instanceof"](JS.BreakStatement, JS.ContinueStatement, JS.ReturnStatement)) {
    throw new Error("pure statement in an expression");
  } else if (s["instanceof"](JS.ExpressionStatement)) {
    return s.expression;
  } else if (s["instanceof"](JS.IfStatement)) {
    consequent = expr((_ref3 = s.consequent) != null ? _ref3 : helpers.undef());
    alternate = expr((_ref4 = s.alternate) != null ? _ref4 : helpers.undef());
    return new JS.ConditionalExpression(s.test, consequent, alternate);
  } else if (s["instanceof"](JS.ForInStatement, JS.WhileStatement)) {
    accum = genSym('accum');
    s.body = forceBlock(s.body);
    push = new JS.MemberExpression(false, accum, new JS.Identifier('push'));
    s.body.body[s.body.body.length - 1] = stmt(new JS.CallExpression(push, [expr(s.body.body.slice(-1)[0])]));
    block = new JS.BlockStatement([s, new JS.ReturnStatement(accum)]);
    iife = new JS.FunctionExpression(null, [accum], block);
    return new JS.CallExpression(iife, [new JS.ArrayExpression([])]);
  } else if (s["instanceof"](JS.SwitchStatement)) {
    block = new JS.BlockStatement([makeReturn(s)]);
    iife = new JS.FunctionExpression(null, [], block);
    return new JS.CallExpression(iife, []);
  } else {
    throw new Error("expr: " + s.type);
  }
};

makeReturn = function(node) {
  var stmts;
  if (node == null) {
    return new JS.ReturnStatement(helpers.undef());
  }
  if (node["instanceof"](JS.BlockStatement)) {
    return new JS.BlockStatement(__slice.call(node.body.slice(0, -1)).concat([makeReturn(node.body.slice(-1)[0])]));
  } else if (node["instanceof"](JS.SequenceExpression)) {
    return new JS.SequenceExpression(__slice.call(node.expressions.slice(0, -1)).concat([makeReturn(node.expressions.slice(-1)[0])]));
  } else if (node["instanceof"](JS.IfStatement)) {
    return new JS.IfStatement(node.test, makeReturn(node.consequent), makeReturn(node.alternate));
  } else if (node["instanceof"](JS.SwitchStatement)) {
    return new JS.SwitchStatement(node.discriminant, map(node.cases, makeReturn));
  } else if (node["instanceof"](JS.SwitchCase)) {
    if (!node.consequent.length) {
      return node;
    }
    stmts = node.consequent.slice(-1)[0]["instanceof"](JS.BreakStatement) ? node.consequent.slice(0, -1) : node.consequent;
    return new JS.SwitchCase(node.test, __slice.call(stmts.slice(0, -1)).concat([makeReturn(stmts.slice(-1)[0])]));
  } else if (node["instanceof"](JS.ThrowStatement)) {
    return node;
  } else {
    return new JS.ReturnStatement(expr(node));
  }
};

declarationsNeededFor = function(node) {
  if (node == null) {
    return [];
  }
  return nub((node["instanceof"](JS.AssignmentExpression)) && node.operator === '=' && node.left["instanceof"](JS.Identifier) ? union([node.left], declarationsNeededFor(node.right)) : node["instanceof"](JS.ForInStatement) ? union([node.left], concatMap([node.right, node.body], declarationsNeededFor)) : node["instanceof"](JS.FunctionExpression, JS.FunctionDeclaration) ? [] : concatMap(node.childNodes, function(childName) {
    if (node[childName] == null) {
      return [];
    }
    if (__indexOf.call(node.listMembers, childName) >= 0) {
      return concatMap(node[childName], declarationsNeededFor);
    } else {
      return declarationsNeededFor(node[childName]);
    }
  }));
};

collectIdentifiers = function(node) {
  return nub((function() {
    switch (false) {
      case !node["instanceof"](JS.Identifier):
        return [node.name];
      case !((node["instanceof"](JS.MemberExpression)) && !node.computed):
        return collectIdentifiers(node.object);
      default:
        return concatMap(node.childNodes, function(childName) {
          if (node[childName] == null) {
            return [];
          }
          if (__indexOf.call(node.listMembers, childName) >= 0) {
            return concatMap(node[childName], collectIdentifiers);
          } else {
            return collectIdentifiers(node[childName]);
          }
        });
    }
  })());
};

needsCaching = function(node) {
  return (envEnrichments(node, [])).length > 0 || (node["instanceof"](CS.FunctionApplications, CS.DoOp, CS.NewOp)) || (any(difference(node.childNodes, node.listMembers), function(n) {
    return needsCaching(node[n]);
  })) || (any(node.listMembers, function(n) {
    return any(node[n], needsCaching);
  }));
};

forceBlock = function(node) {
  if (node == null) {
    return node;
  }
  node = stmt(node);
  if (node["instanceof"](JS.BlockStatement)) {
    return node;
  } else {
    return new JS.BlockStatement([node]);
  }
};

makeVarDeclaration = function(vars) {
  var decls, v;
  vars.sort(function(a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  });
  decls = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      v = vars[_i];
      _results.push(new JS.VariableDeclarator(v));
    }
    return _results;
  })();
  return new JS.VariableDeclaration('var', decls);
};

helperNames = {};

helpers = {
  isOwn: function() {
    var args, functionBody, hop, params;
    hop = new JS.MemberExpression(false, new JS.ObjectExpression([]), new JS.Identifier('hasOwnProperty'));
    params = args = [new JS.Identifier('o'), new JS.Identifier('p')];
    functionBody = [new JS.CallExpression(new JS.MemberExpression(false, hop, new JS.Identifier('call')), args)];
    return new JS.FunctionDeclaration(helperNames.isOwn, params, makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  },
  indexOf: function() {
    var functionBody, i, length, list, loopBody, member, varDeclaration;
    member = new JS.Identifier('member');
    list = new JS.Identifier('list');
    i = genSym('i');
    length = genSym('length');
    varDeclaration = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, new JS.Literal(0)), new JS.VariableDeclarator(length, new JS.MemberExpression(false, list, new JS.Identifier('length')))]);
    loopBody = new JS.IfStatement(new JS.BinaryExpression('&&', new JS.BinaryExpression('in', i, list), new JS.BinaryExpression('===', new JS.MemberExpression(true, list, i), member)), new JS.ReturnStatement(i));
    functionBody = [new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), loopBody), new JS.UnaryExpression('-', new JS.Literal(1))];
    return new JS.FunctionDeclaration(helperNames.indexOf, [member, list], makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  }
};

enabledHelpers = [];

for (h in helpers) {
  fn = helpers[h];
  helperNames[h] = genSym(h);
  helpers[h] = (function(h, fn) {
    return function() {
      enabledHelpers.push(fn());
      return (helpers[h] = function() {
        return new JS.CallExpression(helperNames[h], arguments);
      }).apply(this, arguments);
    };
  })(h, fn);
}

inlineHelpers = {
  undef: function() {
    return new JS.UnaryExpression('void', new JS.Literal(0));
  }
};

for (h in inlineHelpers) {
  fn = inlineHelpers[h];
  helpers[h] = fn;
}

exports.Compiler = (function() {
  var defaultRules,
    _this = this;

  Compiler.compile = function() {
    var _ref3;
    return (_ref3 = new Compiler).compile.apply(_ref3, arguments);
  };

  defaultRules = [
    [
      CS.Program, function(_arg) {
        var block, decls, inScope, options, program;
        block = _arg.block, inScope = _arg.inScope, options = _arg.options;
        if (block == null) {
          return new JS.Program([]);
        }
        block = stmt(block);
        block = block["instanceof"](JS.BlockStatement) ? block.body : [block];
        [].push.apply(block, enabledHelpers);
        block = [stmt(new JS.CallExpression(new JS.MemberExpression(false, new JS.FunctionExpression(null, [], new JS.BlockStatement(block)), new JS.Identifier('call')), [new JS.ThisExpression]))];
        decls = nub(concatMap(block, declarationsNeededFor));
        if (decls.length > 0) {
          block.unshift(makeVarDeclaration(decls));
        }
        program = new JS.Program(block);
        program.comments = [
          {
            type: 'Line',
            value: ' Generated by CoffeeScript 2.0.0'
          }
        ];
        return program;
      }
    ], [
      CS.Block, function(_arg) {
        var statements;
        statements = _arg.statements;
        switch (statements.length) {
          case 0:
            return new JS.EmptyStatement;
          case 1:
            return new stmt(statements[0]);
          default:
            return new JS.BlockStatement(map(statements, stmt));
        }
      }
    ], [
      CS.SeqOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.SequenceExpression([left, right]);
      }
    ], [
      CS.Conditional, function(_arg) {
        var block, compile, condition, elseBlock;
        condition = _arg.condition, block = _arg.block, elseBlock = _arg.elseBlock, compile = _arg.compile;
        return new JS.IfStatement(expr(condition), forceBlock(block), forceBlock(elseBlock));
      }
    ], [
      CS.ForOf, function(_arg) {
        var block, compile, expression, filterExpr, keyAssignee, valAssignee;
        keyAssignee = _arg.keyAssignee, valAssignee = _arg.valAssignee, expression = _arg.expression, filterExpr = _arg.filterExpr, block = _arg.block, compile = _arg.compile;
        block = forceBlock(block);
        if (this.filterExpr != null) {
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filterExpr), new JS.ContinueStatement)));
        }
        if (this.valAssignee != null) {
          block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, new JS.MemberExpression(true, expr(expression), keyAssignee))));
        }
        if (this.isOwn) {
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', helpers.isOwn(expr(expression), keyAssignee)), new JS.ContinueStatement)));
        }
        return new JS.ForInStatement(keyAssignee, expr(expression), block);
      }
    ], [
      CS.While, function(_arg) {
        var block, condition;
        condition = _arg.condition, block = _arg.block;
        return new JS.WhileStatement(expr(condition), forceBlock(block));
      }
    ], [
      CS.Switch, function(_arg) {
        var c, cases, elseBlock, expression, _i, _len, _ref3;
        expression = _arg.expression, cases = _arg.cases, elseBlock = _arg.elseBlock;
        cases = concat(cases);
        if (elseBlock != null) {
          cases.push(new JS.SwitchCase(null, [stmt(elseBlock)]));
        }
        _ref3 = cases.slice(0, -1);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          c = _ref3[_i];
          if (c.consequent.length > 0) {
            c.consequent.push(new JS.BreakStatement);
          }
        }
        return new JS.SwitchStatement(expression, cases);
      }
    ], [
      CS.SwitchCase, function(_arg) {
        var block, cases, conditions;
        conditions = _arg.conditions, block = _arg.block;
        cases = map(conditions, function(c) {
          return new JS.SwitchCase(c, []);
        });
        block = stmt(block);
        block = block["instanceof"](JS.BlockStatement) ? block.body : [block];
        cases[cases.length - 1].consequent = block;
        return cases;
      }
    ], [
      CS.Throw, function(_arg) {
        var expression;
        expression = _arg.expression;
        return new JS.ThrowStatement(expression);
      }
    ], [
      CS.ArrayInitialiser, function(_arg) {
        var members;
        members = _arg.members;
        return new JS.ArrayExpression(map(members, expr));
      }
    ], [
      CS.ObjectInitialiser, function(_arg) {
        var members;
        members = _arg.members;
        return new JS.ObjectExpression(members);
      }
    ], [
      CS.ObjectInitialiserMember, function(_arg) {
        var expression, key;
        key = _arg.key, expression = _arg.expression;
        return new JS.Property(key, expr(expression));
      }
    ], [
      CS.Function, function(_arg) {
        var block, parameters;
        parameters = _arg.parameters, block = _arg.block;
        return new JS.FunctionExpression(null, parameters, forceBlock(makeReturn(block)));
      }
    ], [
      CS.AssignOp, function(_arg) {
        var assignee, assignments, compile, e, expression, i, m, _i, _j, _len, _len1, _ref3, _ref4;
        assignee = _arg.assignee, expression = _arg.expression, compile = _arg.compile;
        switch (false) {
          case !this.assignee["instanceof"](CS.ArrayInitialiser):
            assignments = [];
            e = this.expression;
            if (needsCaching(this.expression)) {
              e = new CS.GenSym('cache');
              assignments.push(new CS.AssignOp(e, this.expression));
            }
            _ref3 = this.assignee.members;
            for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
              m = _ref3[i];
              assignments.push(new CS.AssignOp(m, new CS.DynamicMemberAccessOp(e, new CS.Int(i))));
            }
            if (!assignments.length) {
              return helpers.undef();
            }
            return compile(foldl1(assignments, function(a, b) {
              return new CS.SeqOp(a, b);
            }));
          case !this.assignee["instanceof"](CS.ObjectInitialiser):
            assignments = [];
            e = this.expression;
            if (needsCaching(this.expression)) {
              e = new CS.GenSym('cache');
              assignments.push(new CS.AssignOp(e, this.expression));
            }
            _ref4 = this.assignee.members;
            for (i = _j = 0, _len1 = _ref4.length; _j < _len1; i = ++_j) {
              m = _ref4[i];
              assignments.push(new CS.AssignOp(m.expression, new CS.MemberAccessOp(e, m.key.data)));
            }
            if (!assignments.length) {
              return helpers.undef();
            }
            return compile(foldl1(assignments, function(a, b) {
              return new CS.SeqOp(a, b);
            }));
          case !this.assignee["instanceof"](CS.Identifier, CS.GenSym, CS.MemberAccessOps):
            return new JS.AssignmentExpression('=', assignee, expr(expression));
          default:
            throw new Error("compile: AssignOp: unassignable assignee: " + this.assignee.className);
        }
      }
    ], [
      CS.FunctionApplication, function(_arg) {
        var args, fn;
        fn = _arg["function"], args = _arg["arguments"];
        return new JS.CallExpression(expr(fn), map(args, expr));
      }
    ], [
      CS.NewOp, function(_arg) {
        var args, ctor;
        ctor = _arg.ctor, args = _arg["arguments"];
        return new JS.NewExpression(ctor, args);
      }
    ], [
      CS.HeregExp, function(_arg) {
        var expression, flag, flags;
        expression = _arg.expression;
        flags = ((function() {
          var _i, _len, _ref3, _results;
          _ref3 = ['g', 'i', 'm', 'y'];
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            flag = _ref3[_i];
            if (this.flags[flag]) {
              _results.push(flag);
            }
          }
          return _results;
        }).call(this)).join('');
        return new JS.NewExpression(new JS.Identifier('RegExp'), [expression, new JS.Literal(flags)]);
      }
    ], [
      CS.RegExp, function() {
        var flag, flags, re;
        flags = ((function() {
          var _i, _len, _ref3, _results;
          _ref3 = ['g', 'i', 'm', 'y'];
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            flag = _ref3[_i];
            if (this.flags[flag]) {
              _results.push(flag);
            }
          }
          return _results;
        }).call(this)).join('');
        re = new RegExp(this.data, flags);
        return new JS.Literal(re);
      }
    ], [
      CS.ConcatOp, function(_arg) {
        var ancestry, left, leftmost, plusOp, right, _ref3;
        left = _arg.left, right = _arg.right, ancestry = _arg.ancestry;
        plusOp = new JS.BinaryExpression('+', left, right);
        if (!ancestry[0]["instanceof"](CS.ConcatOp)) {
          leftmost = plusOp;
          while ((_ref3 = leftmost.left) != null ? _ref3.left : void 0) {
            leftmost = leftmost.left;
          }
          if (!leftmost.left["instanceof"](JS.Literal)) {
            leftmost.left = new JS.BinaryExpression('+', new JS.Literal(''), leftmost.left);
          }
        }
        return plusOp;
      }
    ], [
      CS.MemberAccessOp, function(_arg) {
        var expression, _ref3;
        expression = _arg.expression;
        if (_ref3 = this.memberName, __indexOf.call(jsReserved, _ref3) >= 0) {
          return new JS.MemberExpression(true, expr(expression), new JS.Literal(this.memberName));
        } else {
          return new JS.MemberExpression(false, expr(expression), new JS.Identifier(this.memberName));
        }
      }
    ], [
      CS.DynamicMemberAccessOp, function(_arg) {
        var expression, indexingExpr;
        expression = _arg.expression, indexingExpr = _arg.indexingExpr;
        return new JS.MemberExpression(true, expression, indexingExpr);
      }
    ], [
      CS.SoakedMemberAccessOp, function(_arg) {
        var access, condition, e, expression, inScope, node, _ref3, _ref4;
        expression = _arg.expression, inScope = _arg.inScope;
        e = needsCaching(this.expression) ? genSym('cache') : expression;
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
        if ((e["instanceof"](JS.Identifier)) && (_ref3 = e.name, __indexOf.call(inScope, _ref3) < 0)) {
          condition = new JS.BinaryExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
        }
        access = (_ref4 = this.memberName, __indexOf.call(jsReserved, _ref4) >= 0) ? new JS.MemberExpression(true, expr(e), new JS.Literal(this.memberName)) : new JS.MemberExpression(false, expr(e), new JS.Identifier(this.memberName));
        node = new JS.ConditionalExpression(condition, access, helpers.undef());
        if (e === expression) {
          return node;
        } else {
          return new JS.SequenceExpression([new JS.AssignmentExpression('=', e, expression), node]);
        }
      }
    ], [
      CS.ExistsOp, function(_arg) {
        var condition, e, inScope, left, node, right, _ref3;
        left = _arg.left, right = _arg.right, inScope = _arg.inScope;
        e = needsCaching(this.left) ? genSym('cache') : left;
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
        if ((e["instanceof"](JS.Identifier)) && (_ref3 = e.name, __indexOf.call(inScope, _ref3) < 0)) {
          condition = new JS.BinaryExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
        }
        node = new JS.ConditionalExpression(condition, e, right);
        if (e === left) {
          return node;
        } else {
          return new JS.SequenceExpression([new JS.AssignmentExpression('=', e, left), node]);
        }
      }
    ], [
      CS.UnaryExistsOp, function(_arg) {
        var compile, expression, inScope, nullTest, typeofTest, _ref3;
        expression = _arg.expression, inScope = _arg.inScope, compile = _arg.compile;
        nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
        if ((expression["instanceof"](JS.Identifier)) && (_ref3 = expression.name, __indexOf.call(inScope, _ref3) < 0)) {
          typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
          return new JS.BinaryExpression('&&', typeofTest, nullTest);
        } else {
          return nullTest;
        }
      }
    ], [
      CS.DoOp, function(_arg) {
        var args, compile, expression, param;
        expression = _arg.expression, compile = _arg.compile;
        args = [];
        if (this.expression["instanceof"](CS.Function)) {
          args = (function() {
            var _i, _len, _ref3, _results;
            _ref3 = this.expression.parameters;
            _results = [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              param = _ref3[_i];
              switch (false) {
                case !param["instanceof"](CS.AssignOp):
                  _results.push(param.expression);
                  break;
                case !param["instanceof"](CS.Identifier, CS.MemberAccessOp):
                  _results.push(param);
                  break;
                default:
                  _results.push(helpers.undef());
              }
            }
            return _results;
          }).call(this);
        }
        return compile(new CS.FunctionApplication(this.expression, args));
      }
    ], [
      CS.Return, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.ReturnStatement(expr(e));
      }
    ], [
      CS.Break, function() {
        return new JS.BreakStatement;
      }
    ], [
      CS.Continue, function() {
        return new JS.ContinueStatement;
      }
    ], [
      CS.DivideOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('/', expr(left), expr(right));
      }
    ], [
      CS.MultiplyOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('*', expr(left), expr(right));
      }
    ], [
      CS.RemOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('%', expr(left), expr(right));
      }
    ], [
      CS.PlusOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('+', expr(left), expr(right));
      }
    ], [
      CS.SubtractOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('-', expr(left), expr(right));
      }
    ], [
      CS.OfOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('in', expr(left), expr(right));
      }
    ], [
      CS.InOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return helpers.indexOf(expr(left), expr(right));
      }
    ], [
      CS.InstanceofOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('instanceof', expr(left), expr(right));
      }
    ], [
      CS.LogicalAndOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('&&', expr(left), expr(right));
      }
    ], [
      CS.LogicalOrOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('||', expr(left), expr(right));
      }
    ], [
      CS.EQOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('===', expr(left), expr(right));
      }
    ], [
      CS.NEQOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('!==', expr(left), expr(right));
      }
    ], [
      CS.GTEOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>=', expr(left), expr(right));
      }
    ], [
      CS.GTOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>', expr(left), expr(right));
      }
    ], [
      CS.LTEOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<=', expr(left), expr(right));
      }
    ], [
      CS.LTOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<', expr(left), expr(right));
      }
    ], [
      CS.BitAndOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('&', expr(left), expr(right));
      }
    ], [
      CS.BitOrOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('|', expr(left), expr(right));
      }
    ], [
      CS.BitXorOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('^', expr(left), expr(right));
      }
    ], [
      CS.LeftShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('<<', expr(left), expr(right));
      }
    ], [
      CS.SignedRightShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>>', expr(left), expr(right));
      }
    ], [
      CS.UnsignedRightShiftOp, function(_arg) {
        var left, right;
        left = _arg.left, right = _arg.right;
        return new JS.BinaryExpression('>>>', expr(left), expr(right));
      }
    ], [
      CS.PreIncrementOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UpdateExpression('++', true, expr(e));
      }
    ], [
      CS.LogicalNotOp, function(_arg) {
        var e;
        e = _arg.expression;
        return new JS.UnaryExpression('!', expr(e));
      }
    ], [
      CS.Identifier, function() {
        return new JS.Identifier(this.data);
      }
    ], [
      CS.GenSym, (function() {
        var memos, symbols;
        symbols = [];
        memos = [];
        return function() {
          var memo;
          if (__indexOf.call(symbols, this) >= 0) {
            return memos[symbols.indexOf(this)];
          } else {
            symbols.push(this);
            memos.push(memo = genSym(this.data));
            return memo;
          }
        };
      })()
    ], [
      CS.Bool, CS.Int, CS.Float, CS.String, function() {
        return new JS.Literal(this.data);
      }
    ], [
      CS.Null, function() {
        return new JS.Literal(null);
      }
    ], [
      CS.Undefined, function() {
        return helpers.undef();
      }
    ], [
      CS.This, function() {
        return new JS.ThisExpression;
      }
    ]
  ];

  function Compiler() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref3;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref3 = defaultRules[_i], ctors = 2 <= _ref3.length ? __slice.call(_ref3, 0, _j = _ref3.length - 1) : (_j = 0, []), handler = _ref3[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Compiler.prototype.addRule = function(ctor, handler) {
    this.rules[ctor] = handler;
    return this;
  };

  Compiler.prototype.compile = (function() {
    var defaultRule, generateSymbols, walk;
    walk = function(fn, inScope, ancestry) {
      var child, childName, children, jsNode, member, _i, _len, _ref3, _ref4;
      if (inScope == null) {
        inScope = [];
      }
      if (ancestry == null) {
        ancestry = [];
      }
      if (((_ref3 = ancestry[0]) != null ? _ref3["instanceof"](CS.Function, CS.BoundFunction) : void 0) && this === ancestry[0].block) {
        inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
      }
      ancestry.unshift(this);
      children = {};
      _ref4 = this.childNodes;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        childName = _ref4[_i];
        if (this[childName] != null) {
          children[childName] = (function() {
            var _j, _len1, _ref5, _results;
            if (__indexOf.call(this.listMembers, childName) >= 0) {
              _ref5 = this[childName];
              _results = [];
              for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
                member = _ref5[_j];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                _results.push(jsNode);
              }
              return _results;
            } else {
              child = this[childName];
              jsNode = walk.call(child, fn, inScope, ancestry);
              inScope = union(inScope, envEnrichments(child, inScope));
              return jsNode;
            }
          }).call(this);
        }
      }
      children.inScope = inScope;
      children.ancestry = ancestry;
      children.compile = function(node) {
        return walk.call(node.g(), fn, inScope, ancestry);
      };
      ancestry.shift();
      return fn.call(this, children);
    };
    generateSymbols = (function() {
      var format, generateName, generatedSymbols, handleNode;
      generatedSymbols = {};
      format = function(pre, counter) {
        return "" + pre + "$" + (counter || '');
      };
      generateName = function(node, _arg) {
        var formatted, nsCounters, usedSymbols, _ref3;
        usedSymbols = _arg.usedSymbols, nsCounters = _arg.nsCounters;
        if (owns(generatedSymbols, node.uniqueId)) {
          return generatedSymbols[node.uniqueId];
        } else {
          nsCounters[node.ns] = owns(nsCounters, node.ns) ? 1 + nsCounters[node.ns] : 0;
          while (_ref3 = (formatted = format(node.ns, nsCounters[node.ns])), __indexOf.call(usedSymbols, _ref3) >= 0) {
            ++nsCounters[node.ns];
          }
          return generatedSymbols[node.uniqueId] = formatted;
        }
      };
      handleNode = function(node, state) {
        var declNames, declaredSymbols, decls, k, newNode, nsCounters, params, usedSymbols, v;
        declaredSymbols = state.declaredSymbols, usedSymbols = state.usedSymbols, nsCounters = state.nsCounters;
        newNode = (function() {
          if (node["instanceof"](JS.GenSym)) {
            newNode = new JS.Identifier(generateName(node, state));
            usedSymbols.push(newNode.name);
            return newNode;
          } else if (node["instanceof"](JS.FunctionExpression, JS.FunctionDeclaration)) {
            params = concatMap(node.params, collectIdentifiers);
            state.usedSymbols = nub(__slice.call(usedSymbols).concat(__slice.call(params)));
            state.nsCounters = {};
            for (k in nsCounters) {
              if (!__hasProp.call(nsCounters, k)) continue;
              v = nsCounters[k];
              state.nsCounters[k] = v;
            }
            newNode = generateSymbols(node, state);
            declNames = nub(difference(map(concatMap(node.body.body, declarationsNeededFor), function(id) {
              return id.name;
            }), declaredSymbols));
            decls = map(declNames, function(name) {
              return new JS.Identifier(name);
            });
            if (decls.length > 0) {
              newNode.body.body.unshift(makeVarDeclaration(decls));
            }
            return newNode;
          } else {
            return generateSymbols(node, state);
          }
        })();
        state.declaredSymbols = union(declaredSymbols, map(declarationsNeededFor(newNode), function(id) {
          return id.name;
        }));
        return newNode;
      };
      return function(node, state) {
        var childName, n, _i, _len, _ref3;
        _ref3 = node.childNodes;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          childName = _ref3[_i];
          if (node[childName] == null) {
            continue;
          }
          node[childName] = (function() {
            var _j, _len1, _ref4, _results;
            if (__indexOf.call(node.listMembers, childName) >= 0) {
              _ref4 = node[childName];
              _results = [];
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                n = _ref4[_j];
                _results.push(handleNode(n, state));
              }
              return _results;
            } else {
              return handleNode(node[childName], state);
            }
          })();
        }
        return node;
      };
    })();
    defaultRule = function() {
      throw new Error("compile: Non-exhaustive patterns in case: " + this.className);
    };
    return function(ast) {
      var jsAST, rules;
      rules = this.rules;
      jsAST = walk.call(ast, function() {
        var _ref3;
        return ((_ref3 = rules[this.className]) != null ? _ref3 : defaultRule).apply(this, arguments);
      });
      return generateSymbols(jsAST, {
        declaredSymbols: [],
        usedSymbols: collectIdentifiers(jsAST),
        nsCounters: {}
      });
    };
  })();

  return Compiler;

}).call(this);
