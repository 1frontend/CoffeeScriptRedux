// Generated by CoffeeScript 1.3.3
(function() {
  var defaultRules, down, up,
    __hasProp = {}.hasOwnProperty;

  this.Optimiser = (function() {

    function Optimiser() {
      var applicableCtors, ctor, directions, handler, _i, _j, _len, _len1, _ref;
      this.rules = {};
      for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
        _ref = defaultRules[_i], directions = _ref[0], applicableCtors = _ref[1], handler = _ref[2];
        for (_j = 0, _len1 = applicableCtors.length; _j < _len1; _j++) {
          ctor = applicableCtors[_j];
          this.addRule(directions, ctor.className, handler);
        }
      }
    }

    Optimiser.prototype.addRule = function(directions, ctor, handler) {
      var dir, _base, _base1, _ref, _ref1;
      for (dir in directions) {
        if (!__hasProp.call(directions, dir)) continue;
        ((_ref = (_base = ((_ref1 = (_base1 = this.rules)[dir]) != null ? _ref1 : _base1[dir] = {}))[ctor]) != null ? _ref : _base[ctor] = []).push(handler);
      }
    };

    return Optimiser;

  })();

  down = up = true;

  defaultRules = [
    [
      {
        down: down,
        up: up
      }, [Block], function(inScope, ancestors) {
        var newNode;
        newNode = Block.wrap((function() {
          var blockSize, canDropLast, i, isLast, s, _i, _len, _ref, _ref1, _results;
          canDropLast = ((_ref = ancestors[0]) != null ? _ref.className : void 0) === 'Program';
          blockSize = block.statements.length;
          _ref1 = block.statements;
          _results = [];
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            s = _ref1[i];
            isLast = i + 1 === blockSize;
            if (!((s.mayHaveSideEffects(inScope)) || (isLast && !canDropLast))) {
              continue;
            }
            _results.push(s);
          }
          return _results;
        })());
        return newNode.r(this.raw).p(this.line, this.column);
      }
    ], [
      {
        down: down
      }, [While], function(inScope) {
        if (this.condition.isFalsey()) {
          if (this.condition.mayHaveSideEffects(inScope)) {
            return this.condition;
          } else {
            return (new Null).g();
          }
        }
        if (this.condition.isTruthy()) {
          if (!this.condition.mayHaveSideEffects(inScope)) {
            return new Loop(this.block);
          }
        }
        return this;
      }
    ], [
      {
        down: down
      }, [ForIn], function() {
        if (!(this.expr.className === 'ArrayInitialiser' && this.expr.members.length === 0)) {
          return this;
        }
        return (new ArrayInitialiser([])).g().r(this.raw).p(this.line, this.column);
      }
    ], [
      {
        down: down
      }, [ForOf], function() {
        if (!(this.expr.className === 'ObjectInitialiser' && this.expr.isOwn && this.expr.members.length === 0)) {
          return this;
        }
        return (new ArrayInitialiser([])).g().r(this.raw).p(this.line, this.column);
      }
    ], [
      {
        down: down
      }, [DoOp], function() {
        var args;
        args = [];
        if (this.expr.className === 'Function') {
          args = (function() {
            var param, _i, _len, _ref, _results;
            _ref = this.expr.parameters;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              param = _ref[_i];
              switch (param.className) {
                case 'AssignOp':
                  _results.push(param.expr);
                  break;
                case 'Identifier':
                case 'MemberAccessOp':
                  _results.push(param);
                  break;
                default:
                  _results.push((new Undefined).g());
              }
            }
            return _results;
          })();
        }
        return (new FunctionApplication(this.expr, args)).g().p(this.line, this.column);
      }
    ], [
      {
        up: up
      }, [LogicalNotOp], function() {
        var newNode;
        newNode = (function() {
          switch (this.expr.className) {
            case 'Int':
            case 'Float':
            case 'String':
            case 'Bool':
              return (new Bool(!this.expr.data)).g();
            case 'Function':
            case 'BoundFunction':
              return (new Bool(false)).g();
            case 'Null':
            case 'Undefined':
              return (new Bool(true)).g();
            case 'ArrayInitialiser':
            case 'ObjectInitialiser':
              if (this.expr.mayHaveSideEffects()) {
                return this;
              } else {
                return (new Bool(false)).g();
              }
              break;
            case 'LogicalNotOp':
              if (this.expr.expr.className === 'LogicalNotOp') {
                return this.expr.expr;
              } else {
                return this;
              }
              break;
            default:
              return this;
          }
        }).call(this);
        if (newNode === this) {
          return this;
        }
        return newNode.r(this.raw).p(this.line, this.column);
      }
    ]
  ];

}).call(this);
