// Generated by CoffeeScript 1.3.3
(function() {
  var defaultRules, down, up,
    __hasProp = {}.hasOwnProperty;

  this.Optimiser = (function() {

    function Optimiser() {
      var applicableCtors, ctor, directions, handler, _i, _j, _len, _len1, _ref;
      this.rules = {};
      for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
        _ref = defaultRules[_i], directions = _ref[0], applicableCtors = _ref[1], handler = _ref[2];
        for (_j = 0, _len1 = applicableCtors.length; _j < _len1; _j++) {
          ctor = applicableCtors[_j];
          this.addRule(directions, ctor, handler);
        }
      }
    }

    Optimiser.prototype.addRule = function(directions, ctor, handler) {
      var dir, _base, _base1, _ref, _ref1;
      for (dir in directions) {
        if (!__hasProp.call(directions, dir)) continue;
        ((_ref = (_base = ((_ref1 = (_base1 = this.rules)[dir]) != null ? _ref1 : _base1[dir] = {}))[ctor]) != null ? _ref : _base[ctor] = []).push(handler);
      }
    };

    return Optimiser;

  })();

  down = up = true;

  defaultRules = [
    [
      {
        down: down,
        up: up
      }, ['Block'], function(node) {
        var newNode;
        newNode = Block.wrap((function() {
          var blockSize, canDropLast, i, isLast, s, _i, _len, _ref, _ref1, _results;
          canDropLast = ((_ref = ancestors[0]) != null ? _ref.className : void 0) === 'Program';
          blockSize = block.statements.length;
          _ref1 = block.statements;
          _results = [];
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            s = _ref1[i];
            isLast = i + 1 === blockSize;
            if (!(s.mayHaveSideEffects() || (isLast && !canDropLast))) {
              continue;
            }
            _results.push(s);
          }
          return _results;
        })());
        return newNode.r(node.raw).p(node.line, node.column);
      }
    ], [
      {
        down: down
      }, ['ForIn'], function(node) {
        if (!(node.expr.className === 'ArrayInitialiser' && node.expr.members.length === 0)) {
          return node;
        }
        return (new ArrayInitialiser([])).g().r(node.raw).p(node.line, node.column);
      }
    ], [
      {
        down: down
      }, ['ForOf'], function(node) {
        if (!(node.expr.className === 'ObjectInitialiser' && node.expr.isOwn && node.expr.members.length === 0)) {
          return node;
        }
        return (new ArrayInitialiser([])).g().r(node.raw).p(node.line, node.column);
      }
    ], [
      {
        down: down
      }, ['DoOp'], function(node) {
        var args;
        args = [];
        if (node.expr.className === 'Function') {
          args = (function() {
            var param, _i, _len, _ref, _results;
            _ref = node.expr.parameters;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              param = _ref[_i];
              switch (param.className) {
                case 'AssignOp':
                  _results.push(param.expr);
                  break;
                case 'Identifier':
                case 'MemberExpression':
                  _results.push(param);
                  break;
                default:
                  _results.push(void 0);
              }
            }
            return _results;
          })();
        }
        return (new FunctionApplication(node.expr, args)).g().p(node.line, node.column);
      }
    ], [
      {
        up: up
      }, ['LogicalNotOp'], function(node, ancestors) {
        var newNode;
        newNode = (function() {
          switch (node.expr.className) {
            case 'Int':
            case 'Float':
            case 'String':
            case 'Bool':
              return (new Bool(!node.expr.data)).g();
            case 'Function':
            case 'BoundFunction':
              return (new Bool(false)).g();
            case 'Null':
            case 'Undefined':
              return (new Bool(true)).g();
            case 'ArrayInitialiser':
            case 'ObjectInitialiser':
              if (node.expr.mayHaveSideEffects()) {
                return node;
              } else {
                return (new Bool(false)).g();
              }
              break;
            case 'LogicalNotOp':
              if (node.expr.expr.className === 'LogicalNotOp') {
                return node.expr.expr;
              } else {
                return node;
              }
              break;
            default:
              return node;
          }
        })();
        if (newNode === node) {
          return node;
        } else {
          return newNode.r(node.raw).p(node.line, node.column);
        }
      }
    ]
  ];

}).call(this);
