// Generated by CoffeeScript 1.3.3
var concat, declarationsIn, foldl, foldl1, isFalsey, isFalsey_, isTruthy, isTruthy_, name, node, usedAsExpression, usedAsExpression_, _ref, _ref1,
  __slice = [].slice;

_ref = require('./helpers'), concat = _ref.concat, foldl = _ref.foldl, foldl1 = _ref.foldl1;

_ref1 = require('./nodes');
for (name in _ref1) {
  node = _ref1[name];
  global[name in global ? "CS" + name : name] = node;
}

declarationsIn = function(node) {
  var vars;
  vars = node.envEnrichments();
  return foldl((new Undefined).g(), vars, function(expr, v) {
    return (new AssignOp(v, expr)).g();
  });
};

usedAsExpression_ = function() {
  var grandparent, otherAncestors, parent;
  parent = arguments[0], grandparent = arguments[1], otherAncestors = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  switch (false) {
    case !!(parent != null):
      return true;
    case !parent["instanceof"](Program, Class):
      return false;
    case !parent["instanceof"](SeqOp):
      return this === parent.right;
    case !((parent["instanceof"](Block)) && (parent.statements.indexOf(this)) !== parent.statements.length - 1):
      return false;
    case !((parent["instanceof"](CSFunction, BoundFunction)) && parent.body === this && (grandparent != null ? grandparent["instanceof"](ClassProtoAssignOp) : void 0) && (grandparent.assignee["instanceof"](CSString)) && grandparent.assignee.data === 'constructor'):
      return false;
    default:
      return true;
  }
};

isTruthy_ = function() {
  switch (false) {
    case !this["instanceof"](ArrayInitialiser, Class, DeleteOp, ForIn, ForOf, CSFunction, BoundFunction, HeregExp, ObjectInitialiser, Range, RegExp, Slice, TypeofOp, While):
      return true;
    case !this["instanceof"](AssignOp):
      return isTruthy(this.expr);
    case !this["instanceof"](Block):
      if (this.statements.length === 0) {
        return false;
      } else {
        return isTruthy(this.statements[this.statements.length - 1]);
      }
      break;
    case !this["instanceof"](Bool, Float, Int, CSString):
      return !!this.data;
    case !this["instanceof"](Conditional):
      return (isTruthy(this.condition)) && (isTruthy(this.block)) || (isFalsey(this.condition)) && isTruthy(this.elseBlock);
    case !this["instanceof"](LogicalAndOp):
      return (isTruthy(this.left)) && isTruthy(this.right);
    case !this["instanceof"](LogicalNotOp):
      return isFalsey(this.expr);
    case !this["instanceof"](LogicalOrOp):
      return (isTruthy(this.left)) || isTruthy(this.right);
    case !this["instanceof"](Program):
      return isTruthy(this.block);
    case !this["instanceof"](SeqOp):
      return isTruthy(this.right);
    case !this["instanceof"](UnaryExistsOp):
      return (isTruthy(this.expr)) || this.expr["instanceof"](Int, Float, String, UnaryPlusOp, UnaryNegateOp, LogicalNotOp);
    default:
      return false;
  }
};

isFalsey_ = function() {
  switch (false) {
    case !this["instanceof"](Null, Undefined):
      return true;
    case !this["instanceof"](AssignOp):
      return isFalsey(this.expr);
    case !this["instanceof"](Block):
      if (this.statements.length === 0) {
        return true;
      } else {
        return isFalsey(this.statements[this.statements.length - 1]);
      }
      break;
    case !this["instanceof"](Bool, Float, Int, CSString):
      return !this.data;
    case !this["instanceof"](Conditional):
      return (isTruthy(this.condition)) && (isFalsey(this.block)) || (isFalsey(this.condition)) && isFalsey(this.elseBlock);
    case !this["instanceof"](LogicalAndOp):
      return (isFalsey(this.left)) || isFalsey(this.right);
    case !this["instanceof"](LogicalNotOp):
      return isTruthy(this.expr);
    case !this["instanceof"](LogicalOrOp):
      return (isFalsey(this.left)) && isFalsey(this.right);
    case !this["instanceof"](Program):
      return isFalsey(this.block);
    case !this["instanceof"](SeqOp):
      return isFalsey(this.right);
    case !this["instanceof"](UnaryExistsOp):
      return this.expr["instanceof"](Null, Undefined);
    default:
      return false;
  }
};

isTruthy = function(node) {
  if (node != null) {
    return isTruthy_.call(node);
  } else {
    return false;
  }
};

isFalsey = function(node) {
  if (node != null) {
    return isFalsey_.call(node);
  } else {
    return false;
  }
};

usedAsExpression = function(node, ancestors) {
  return usedAsExpression_.apply(node, ancestors);
};

this.Optimiser = (function() {
  var defaultRules;

  Optimiser.isTruthy = isTruthy;

  Optimiser.isFalsey = isFalsey;

  Optimiser.usedAsExpression = usedAsExpression;

  defaultRules = [
    [
      Program, function() {
        if ((this.block != null) && this.block.mayHaveSideEffects([])) {
          return this;
        } else {
          return new Program(null);
        }
      }
    ], [
      Block, function(inScope, ancestors) {
        var canDropLast, stmts,
          _this = this;
        canDropLast = !usedAsExpression(this, ancestors);
        stmts = concat((function() {
          var i, s, _i, _len, _ref2, _results;
          _ref2 = _this.statements;
          _results = [];
          for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
            s = _ref2[i];
            switch (false) {
              case !((!s.mayHaveSideEffects(inScope)) && (canDropLast || i + 1 !== _this.statements.length)):
                _results.push([declarationsIn(s)]);
                break;
              case !s["instanceof"](Block):
                _results.push(s.statements);
                break;
              case !s["instanceof"](SeqOp):
                _results.push([s.left, s.right]);
                break;
              default:
                _results.push([s]);
            }
          }
          return _results;
        })());
        switch (stmts.length) {
          case 0:
            return (new Undefined).g();
          case 1:
            return stmts[0];
          default:
            return foldl1(stmts, function(expr, s) {
              return new SeqOp(expr, s);
            });
        }
      }
    ], [
      SeqOp, function(inScope, ancestors) {
        if (this.left.mayHaveSideEffects(inScope)) {
          if (this.right.mayHaveSideEffects() || usedAsExpression(this, ancestors)) {
            return this;
          } else {
            return this.left;
          }
        } else if ((this.right["instanceof"](Identifier)) && this.right.data === 'eval') {
          if ((this.left["instanceof"](Int)) && this.left.data === 0) {
            return this;
          }
          return new SeqOp((new Int(0)).g(), this.right);
        } else {
          return this.right;
        }
      }
    ], [
      AssignOp, function() {
        if (!this.expr["instanceof"](SeqOp)) {
          return this;
        }
        return new SeqOp(this.expr.left, new AssignOp(this.assignee, this.expr.right));
      }
    ], [
      While, function(inScope) {
        if (this.condition.isFalsey()) {
          if (this.condition.mayHaveSideEffects(inScope)) {
            return this.condition;
          } else {
            if (typeof block !== "undefined" && block !== null) {
              return declarationsIn(this.block);
            } else {
              return (new Undefined).g();
            }
          }
        }
        if (isTruthy(this.condition)) {
          if (!this.condition.mayHaveSideEffects(inScope)) {
            if (this.block == null) {
              return (new Undefined).g();
            }
            if (this instanceof Loop) {
              return this;
            }
            return (new Loop(this.block)).g();
          }
        }
        return this;
      }
    ], [
      Conditional, function(inScope) {
        var block, removedBlock;
        if (this.condition.isFalsey()) {
          block = this.elseBlock;
          removedBlock = this.block;
        } else if (isTruthy(this.condition)) {
          block = this.block;
          removedBlock = this.elseBlock;
        } else {
          return this;
        }
        if (removedBlock != null) {
          block = new SeqOp(declarationsIn(removedBlock), block);
        }
        if (this.condition.mayHaveSideEffects(inScope)) {
          block = new SeqOp(this.condition, block);
        }
        return block;
      }
    ], [
      ForIn, function(inScope, ancestors) {
        var retVal;
        if (!((this.expr["instanceof"](ArrayInitialiser)) && this.expr.members.length === 0)) {
          return this;
        }
        retVal = usedAsExpression(this, ancestors) ? new ArrayInitialiser([]) : new Undefined;
        return new SeqOp(declarationsIn(this), retVal.g());
      }
    ], [
      ForOf, function() {
        var retVal;
        if (!((this.expr["instanceof"](ObjectInitialiser)) && this.expr.isOwn && this.expr.members.length === 0)) {
          return this;
        }
        retVal = usedAsExpression(this, ancestors) ? new ArrayInitialiser([]) : new Undefined;
        return new SeqOp(declarationsIn(this), retVal.g());
      }
    ], [
      ExistsOp, function() {
        if (this.left["instanceof"](Null, Undefined)) {
          return this.right;
        } else {
          return this;
        }
      }
    ], [
      UnaryExistsOp, function() {
        if (this.expr["instanceof"](Null, Undefined)) {
          return (new Bool(false)).g();
        } else {
          return this;
        }
      }
    ], [
      LogicalNotOp, function() {
        switch (this.expr.className) {
          case Int.prototype.className:
          case Float.prototype.className:
          case String.prototype.className:
          case Bool.prototype.className:
            return (new Bool(!this.expr.data)).g();
          case Function.prototype.className:
          case BoundFunction.prototype.className:
            return (new Bool(false)).g();
          case Null.prototype.className:
          case Undefined.prototype.className:
            return (new Bool(true)).g();
          case ArrayInitialiser.prototype.className:
          case ObjectInitialiser.prototype.className:
            if (this.expr.mayHaveSideEffects()) {
              return this;
            } else {
              return new SeqOp(declarationsIn(this.expr), (new Bool(false)).g());
            }
            break;
          case LogicalNotOp.prototype.className:
            if (this.expr.expr["instanceof"](LogicalNotOp)) {
              return this.expr.expr;
            } else {
              return this;
            }
            break;
          default:
            return this;
        }
      }
    ], [
      TypeofOp, function() {
        switch (this.expr.className) {
          case Int.prototype.className:
          case Float.prototype.className:
          case UnaryNegateOp.prototype.className:
          case UnaryPlusOp.prototype.className:
            return (new String('number')).g();
          case String.prototype.className:
            return (new String('string')).g();
          case Function.prototype.className:
          case BoundFunction.prototype.className:
            return (new String('function')).g();
          case Undefined.prototype.className:
            return (new String('undefined')).g();
          default:
            return this;
        }
      }
    ]
  ];

  function Optimiser() {
    var ctor, ctors, handler, _i, _j, _k, _len, _len1, _ref2;
    this.rules = {};
    for (_i = 0, _len = defaultRules.length; _i < _len; _i++) {
      _ref2 = defaultRules[_i], ctors = 2 <= _ref2.length ? __slice.call(_ref2, 0, _j = _ref2.length - 1) : (_j = 0, []), handler = _ref2[_j++];
      for (_k = 0, _len1 = ctors.length; _k < _len1; _k++) {
        ctor = ctors[_k];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }

  Optimiser.prototype.addRule = function(ctor, handler) {
    var _base, _ref2;
    ((_ref2 = (_base = this.rules)[ctor]) != null ? _ref2 : _base[ctor] = []).push(handler);
  };

  Optimiser.prototype.optimise = function(ast) {
    var rules;
    rules = this.rules;
    return ast.walk(function(inScope, ancestry) {
      var memo, rule, _i, _len, _ref2, _ref3;
      memo = this;
      _ref3 = (_ref2 = rules[this.className]) != null ? _ref2 : [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        rule = _ref3[_i];
        memo = rule.call(memo, inScope, ancestry);
      }
      return memo;
    });
  };

  return Optimiser;

})();
