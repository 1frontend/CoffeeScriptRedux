// Generated by CoffeeScript 1.3.3
var CS, beingDeclared, concat, concatMap, difference, envEnrichments, envEnrichments_, foldl, nub, usedAsExpression, usedAsExpression_, _ref,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

_ref = require('./functional-helpers'), concat = _ref.concat, concatMap = _ref.concatMap, difference = _ref.difference, foldl = _ref.foldl, nub = _ref.nub;

CS = require('./nodes');

this.beingDeclared = beingDeclared = function(assignment) {
  switch (false) {
    case !!(assignment != null):
      return [];
    case !assignment["instanceof"](CS.Identifiers):
      return [assignment.data];
    case !assignment["instanceof"](CS.MemberAccessOps):
      return [];
    case !assignment["instanceof"](CS.AssignOp):
      return beingDeclared(assignment.assignee);
    case !assignment["instanceof"](CS.ArrayInitialiser):
      return concatMap(assignment.members, beingDeclared);
    case !assignment["instanceof"](CS.ObjectInitialiser):
      return concatMap(assignment.vals(), beingDeclared);
    default:
      throw new Error("beingDeclared: Non-exhaustive patterns in case: " + assignment.className);
  }
};

this.declarationsFor = function(node, inScope) {
  var vars;
  vars = envEnrichments(node, inScope);
  return foldl((new CS.Undefined).g(), vars, function(expr, v) {
    return (new CS.AssignOp((new CS.Identifier(v)).g(), expr)).g();
  });
};

usedAsExpression_ = function(ancestors) {
  var grandparent, parent;
  parent = ancestors[0];
  grandparent = ancestors[1];
  switch (false) {
    case !!(parent != null):
      return true;
    case !parent["instanceof"](CS.Program, CS.Class):
      return false;
    case !parent["instanceof"](CS.SeqOp):
      return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
    case !((parent["instanceof"](CS.Block)) && (parent.statements.indexOf(this)) !== parent.statements.length - 1):
      return false;
    case !((parent["instanceof"](CS.Functions)) && parent.body === this && (grandparent != null ? grandparent["instanceof"](CS.Constructor) : void 0)):
      return false;
    default:
      return true;
  }
};

this.usedAsExpression = usedAsExpression = function(node, ancestors) {
  return usedAsExpression_.call(node, ancestors);
};

envEnrichments_ = function(inScope) {
  var possibilities;
  if (inScope == null) {
    inScope = [];
  }
  possibilities = (function() {
    var _this = this;
    switch (false) {
      case !this["instanceof"](CS.AssignOp):
        return nub(beingDeclared(this.assignee));
      case !this["instanceof"](CS.Class):
        return nub(concat([beingDeclared(this.nameAssignee), envEnrichments(this.parent), typeof name !== "undefined" && name !== null ? [name] : []]));
      case !this["instanceof"](CS.ForIn, CS.ForOf):
        return nub(concat([
          concatMap(this.childNodes, function(child) {
            if (__indexOf.call(_this.listMembers, child) >= 0) {
              return concatMap(_this[child], function(m) {
                return envEnrichments(m, inScope);
              });
            } else {
              return envEnrichments(_this[child], inScope);
            }
          }), beingDeclared(this.keyAssignee), beingDeclared(this.valAssignee)
        ]));
      default:
        return nub(concatMap(this.childNodes, function(child) {
          if (__indexOf.call(_this.listMembers, child) >= 0) {
            return concatMap(_this[child], function(m) {
              return envEnrichments(m, inScope);
            });
          } else {
            return envEnrichments(_this[child], inScope);
          }
        }));
    }
  }).call(this);
  return difference(possibilities, inScope);
};

this.envEnrichments = envEnrichments = function() {
  var args, node;
  node = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (node != null) {
    return envEnrichments_.apply(node, args);
  } else {
    return [];
  }
};
