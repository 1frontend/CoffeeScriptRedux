// Generated by CoffeeScript 1.3.3
var CS, beingDeclared, concatMap, envEnrichments, envEnrichments_, foldl, nub, usedAsExpression_, _ref,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ref = require('./functional-helpers'), concatMap = _ref.concatMap, foldl = _ref.foldl, nub = _ref.nub;

CS = require('./nodes');

this.beingDeclared = beingDeclared = function(assignment) {
  switch (false) {
    case !!(assignment != null):
      return [];
    case !assignment["instanceof"](CS.Identifier):
      return [assignment];
    case !assignment["instanceof"](CS.AssignOp):
      return beingDeclared(assignment.assignee);
    case !assignment["instanceof"](CS.ArrayInitialiser):
      return concatMap(assignment.members, beingDeclared);
    case !assignment["instanceof"](CS.ObjectInitialiser):
      return concatMap(assignment.vals(), beingDeclared);
    default:
      throw new Error("beingDeclared: Non-exhaustive patterns in case: " + assignment.className);
  }
};

this.declarationsFor = function(node) {
  var vars;
  vars = envEnrichments(node);
  return foldl((new CS.Undefined).g(), vars, function(expr, v) {
    return (new CS.AssignOp(v, expr)).g();
  });
};

usedAsExpression_ = function() {
  var grandparent, node, otherAncestors, parent;
  node = arguments[0], parent = arguments[1], grandparent = arguments[2], otherAncestors = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
  switch (false) {
    case !!(parent != null):
      return true;
    case !parent["instanceof"](CS.Program, CS.Class):
      return false;
    case !parent["instanceof"](CS.SeqOp):
      return this === parent.right;
    case !((parent["instanceof"](CS.Block)) && (parent.statements.indexOf(this)) !== parent.statements.length - 1):
      return false;
    case !((parent["instanceof"](CS.Function, CS.BoundFunction)) && parent.body === this && (grandparent != null ? grandparent["instanceof"](CS.ClassProtoAssignOp) : void 0) && (grandparent.assignee["instanceof"](CS.String)) && grandparent.assignee.data === 'constructor'):
      return false;
    default:
      return true;
  }
};

this.usedAsExpression = function(node, ancestors) {
  return usedAsExpression_.apply(node, [node].concat(__slice.call(ancestors)));
};

envEnrichments_ = function() {
  var _this = this;
  switch (false) {
    case !this["instanceof"](CS.AssignOp):
      return nub(beingDeclared(this.assignee));
    case !this["instanceof"](CS.Class):
      return nub(concat([beingDeclared(this.nameAssignment), beingDeclared(this.parent), typeof name !== "undefined" && name !== null ? [name] : []]));
    case !this["instanceof"](CS.ForIn, CS.ForOf):
      return nub(concat([
        concatMap(this.childNodes, function(child) {
          if (__indexOf.call(_this.listMembers, child) >= 0) {
            return concatMap(_this[child], function(m) {
              return envEnrichments(m);
            });
          } else {
            return envEnrichments(_this[child]);
          }
        }), beingDeclared(this.keyAssignee), beingDeclared(this.valAssignee)
      ]));
    default:
      return nub(concatMap(this.childNodes, function(child) {
        if (__indexOf.call(_this.listMembers, child) >= 0) {
          return concatMap(_this[child], function(m) {
            return envEnrichments(m);
          });
        } else {
          return envEnrichments(_this[child]);
        }
      }));
  }
};

this.envEnrichments = envEnrichments = function(node) {
  if (node != null) {
    return envEnrichments_.call(node);
  } else {
    return [];
  }
};
