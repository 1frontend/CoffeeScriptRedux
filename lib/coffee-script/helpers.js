// Generated by CoffeeScript 1.3.3
var CS, beingDeclared, concatMap, envEnrichments, envEnrichments_, foldl, nub, usedAsExpression_, _ref,
  __slice = [].slice;

_ref = require('./functional-helpers'), concatMap = _ref.concatMap, foldl = _ref.foldl, nub = _ref.nub;

CS = require('./nodes');

this.beingDeclared = beingDeclared = function(assignment) {
  switch (false) {
    case !assignment["instanceof"](CS.Identifier):
      return [assignment];
    case !assignment["instanceof"](CS.AssignOp):
      return beingDeclared(assignment.assignee);
    case !assignment["instanceof"](CS.ArrayInitialiser):
      return concatMap(assignment.members, beingDeclared);
    case !assignment["instanceof"](CS.ObjectInitialiser):
      return concatMap(assignment.vals(), beingDeclared);
    default:
      throw new Error("beingDeclared: Non-exhaustive patterns in case: " + assignment.className);
  }
};

this.declarationsFor = function(node) {
  var vars;
  vars = envEnrichments(node);
  return foldl((new CS.Undefined).g(), vars, function(expr, v) {
    return (new CS.AssignOp(v, expr)).g();
  });
};

usedAsExpression_ = function() {
  var grandparent, node, otherAncestors, parent;
  node = arguments[0], parent = arguments[1], grandparent = arguments[2], otherAncestors = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
  switch (false) {
    case !!(parent != null):
      return true;
    case !parent["instanceof"](CS.Program, CS.Class):
      return false;
    case !parent["instanceof"](CS.SeqOp):
      return this === parent.right;
    case !((parent["instanceof"](CS.Block)) && (parent.statements.indexOf(this)) !== parent.statements.length - 1):
      return false;
    case !((parent["instanceof"](CS.Function, CS.BoundFunction)) && parent.body === this && (grandparent != null ? grandparent["instanceof"](CS.ClassProtoAssignOp) : void 0) && (grandparent.assignee["instanceof"](CS.String)) && grandparent.assignee.data === 'constructor'):
      return false;
    default:
      return true;
  }
};

this.usedAsExpression = function(node, ancestors) {
  return usedAsExpression_.apply(node, [node].concat(__slice.call(ancestors)));
};

envEnrichments_ = function() {
  var block, cond, conds, declaredInName, otherExprs,
    _this = this;
  switch (false) {
    case !this["instanceof"](CS.ArrayInitialiser):
      return nub(concatMap(this.members, function(m) {
        return envEnrichments(m);
      }));
    case !this["instanceof"](CS.AssignOp):
      return nub(beingDeclared(this.assignee));
    case !this["instanceof"](CS.Block):
      return nub(concatMap(this.statements, function(s) {
        return envEnrichments(s);
      }));
    case !this["instanceof"](CS.Class):
      declaredInName = this.nameAssignment != null ? beingDeclared(this.nameAssignment) : [];
      return nub(declaredInName.concat((typeof name !== "undefined" && name !== null ? [name] : [])));
    case !this["instanceof"](CS.ForIn):
      return nub(concat([
        concatMap(this.childNodes, function(child) {
          return envEnrichments(_this[child]);
        }), beingDeclared(this.valAssignee), this.keyAssignee != null ? beingDeclared(this.keyAssignee) : []
      ]));
    case !this["instanceof"](CS.ForOf):
      return nub(concat([
        concatMap(this.childNodes, function(child) {
          return envEnrichments(_this[child]);
        }), beingDeclared(this.keyAssignee), this.valAssignee != null ? beingDeclared(this.valAssignee) : []
      ]));
    case !this["instanceof"](CS.FunctionApplication):
      return nub(concatMap(this["arguments"], function(arg) {
        return envEnrichments(arg);
      }));
    case !this["instanceof"](CS.ObjectInitialiser):
      return nub(concatMap(this.members, function(_arg) {
        var expr, key;
        key = _arg[0], expr = _arg[1];
        return envEnrichments(expr);
      }));
    case !this["instanceof"](CS.Super):
      return nub(concatMap(this["arguments"], function(a) {
        return envEnrichments(a);
      }));
    case !this["instanceof"](CS.Switch):
      otherExprs = concat((function() {
        var _i, _len, _ref1, _ref2, _results;
        _ref1 = this.cases;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], conds = _ref2[0], block = _ref2[1];
          _results.push(__slice.call((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = conds.length; _j < _len1; _j++) {
                cond = conds[_j];
                _results1.push(cond);
              }
              return _results1;
            })()).concat([block]));
        }
        return _results;
      }).call(this));
      return nub(concatMap([this.expr, this.elseBlock].concat(__slice.call(otherExprs)), function(e) {
        return envEnrichments(e);
      }));
    default:
      return nub(concatMap(this.childNodes, function(child) {
        return envEnrichments(_this[child]);
      }));
  }
};

this.envEnrichments = envEnrichments = function(node) {
  if (node != null) {
    return envEnrichments_.call(node);
  } else {
    return [];
  }
};
