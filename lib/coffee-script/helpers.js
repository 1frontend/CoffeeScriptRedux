// Generated by CoffeeScript 1.3.3
var beingDeclared, foldl, usedAsExpression_,
  __slice = [].slice;

foldl = require('./functional-helpers').foldl;

this.beingDeclared = beingDeclared = function(assignment) {
  switch (assignment.className) {
    case Identifier.prototype.className:
      return [assignment];
    case AssignOp.prototype.className:
      return beingDeclared(assignment.assignee);
    case ArrayInitialiser.prototype.className:
      return concatMap(assignment.members, beingDeclared);
    case ObjectInitialiser.prototype.className:
      return concatMap(assignment.vals(), beingDeclared);
    default:
      throw new Error("beingDeclared: Non-exhaustive patterns in case: " + assignment.className);
  }
};

this.declarationsFor = function(node) {
  var vars;
  vars = node.envEnrichments();
  return foldl((new Undefined).g(), vars, function(expr, v) {
    return (new AssignOp(v, expr)).g();
  });
};

usedAsExpression_ = function() {
  var grandparent, node, otherAncestors, parent;
  node = arguments[0], parent = arguments[1], grandparent = arguments[2], otherAncestors = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
  switch (false) {
    case !!(parent != null):
      return true;
    case !parent["instanceof"](Program, Class):
      return false;
    case !parent["instanceof"](SeqOp):
      return this === parent.right;
    case !((parent["instanceof"](Block)) && (parent.statements.indexOf(this)) !== parent.statements.length - 1):
      return false;
    case !((parent["instanceof"](CSFunction, BoundFunction)) && parent.body === this && (grandparent != null ? grandparent["instanceof"](ClassProtoAssignOp) : void 0) && (grandparent.assignee["instanceof"](CSString)) && grandparent.assignee.data === 'constructor'):
      return false;
    default:
      return true;
  }
};

this.usedAsExpression = function(node, ancestors) {
  return usedAsExpression_.apply(node, [node].concat(__slice.call(ancestors)));
};
