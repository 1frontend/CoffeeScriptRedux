// Generated by CoffeeScript 1.3.3
var $0, Optimiser, Preprocessor, additionalArgs, arg, args, cleanMarkers, concat, filename, foldl, formatOptions, fs, humanReadable, input, inspect, leftColumnWidth, longOptionArguments, longParameterArguments, match, maxWidth, numberLines, o, opt, optionArguments, optionMap, optionRows, options, opts, parameterArguments, parameterRows, parser, path, positionalArgs, printParserError, processInput, reLongOption, reLongParameter, reShortOptions, reShortOptionsShortParameter, reShortParameter, row, rows, shortOptionArguments, shortParameterArguments, wrap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

fs = require('fs');

path = require('path');

_ref = require('./functional-helpers'), concat = _ref.concat, foldl = _ref.foldl;

Preprocessor = require('./preprocessor').Preprocessor;

Optimiser = require('./optimiser').Optimiser;

parser = require('./parser');

inspect = function(o) {
  return (require('util')).inspect(o, false, 9e9, true);
};

cleanMarkers = function(str) {
  return str.replace(/\uEFEF|\uEFFE\uEFFF/g, '');
};

humanReadable = function(str) {
  return (str.replace(/\uEFEF/g, '(INDENT)')).replace(/\uEFFE\uEFFF/g, '(DEDENT)');
};

numberLines = function(input, startLine) {
  var currLine, i, line, lines, numbered, pad, padSize;
  if (startLine == null) {
    startLine = 1;
  }
  lines = input.split('\n');
  padSize = ((lines.length + startLine - 1).toString(10)).length;
  numbered = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      currLine = "" + (i + startLine);
      pad = (Array(padSize + 1).join('0')).slice(currLine.length);
      _results.push("" + pad + currLine + " : " + lines[i]);
    }
    return _results;
  })();
  return numbered.join('\n');
};

printParserError = function(e) {
  var line;
  if (e.found != null) {
    line = (input.split('\n'))[e.line - 1];
    e.column = (cleanMarkers(("" + line + "\n").slice(0, e.column))).length;
  }
  console.error(humanReadable("Syntax error on line " + e.line + ", column " + e.column + ": unexpected " + (e.found != null ? inspect(e.found) : 'end of input')));
  if (e.found != null) {
    console.error(cleanMarkers(line));
    return console.error("" + ((Array(e.column)).join('-')) + "^");
  }
};

args = process.argv.slice(1 + (process.argv[0] === 'node'));

additionalArgs = [];

if (__indexOf.call(args, '--') >= 0) {
  additionalArgs = args.splice(args.indexOf('--'), 9e9);
}

options = {};

optionMap = {};

optionArguments = [[['bare', 'b'], false, 'omit the top-level function wrapper'], [['compile', 'c'], false, 'compile to JavaScript'], [['eval', 'e'], false, 'evaluate compiled javascript'], [['parse', 'p'], false, 'output a JSON-serialised AST representation of the input'], [['jsast', 'j'], false, 'output a JSON-serialised AST representation of the output'], [['lint', 'l'], false, 'pass compiled javascript output through JavaScriptLint'], [['minify', 'm'], false, 'run compiled javascript output through a JS minifier'], [['repl'], false, 'run an interactive CoffeeScript REPL'], [['optimise'], true, 'enable optimisations (default: on)'], [['debug'], false, 'output intermediate representations on stderr for debug'], [['version', 'v'], false, 'display the version number'], [['help'], false, 'display this help message']];

parameterArguments = [[['cli'], 'INPUT', 'pass a string from the command line as input'], [['input', 'i'], 'FILE', 'file to be used as input instead of STDIN'], [['nodejs'], 'OPTS', 'pass options through to the node binary'], [['output', 'o'], 'FILE', 'file to be used as output instead of STDIN'], [['require', 'I'], 'FILE', 'require a library before a script is executed'], [['watch', 'w'], 'FILE', 'watch the given file/directory for changes']];

shortOptionArguments = [];

longOptionArguments = [];

for (_i = 0, _len = optionArguments.length; _i < _len; _i++) {
  opts = optionArguments[_i];
  options[opts[0][0]] = opts[1];
  _ref1 = opts[0];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    o = _ref1[_j];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortOptionArguments.push(o);
    } else if (o.length > 1) {
      longOptionArguments.push(o);
    }
  }
}

shortParameterArguments = [];

longParameterArguments = [];

for (_k = 0, _len2 = parameterArguments.length; _k < _len2; _k++) {
  opts = parameterArguments[_k];
  _ref2 = opts[0];
  for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
    o = _ref2[_l];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortParameterArguments.push(o);
    } else if (o.length > 1) {
      longParameterArguments.push(o);
    }
  }
}

reShortOptions = RegExp("^-(" + (shortOptionArguments.join('|')) + ")+$");

reLongOption = RegExp("^--(no-)?(" + (longOptionArguments.join('|')) + ")$");

reShortParameter = RegExp("^-(" + (shortParameterArguments.join('|')) + ")$");

reLongParameter = RegExp("^--(" + (longParameterArguments.join('|')) + ")$");

reShortOptionsShortParameter = RegExp("^-(" + (shortOptionArguments.join('|')) + ")+(" + (shortParameterArguments.join('|')) + ")$");

positionalArgs = [];

while (args.length) {
  arg = args.shift();
  if (reShortOptionsShortParameter.exec(arg)) {
    args.unshift("-" + arg.slice(1, -1), "-" + arg.slice(-1));
  } else if (reShortOptions.exec(arg)) {
    _ref3 = arg.slice(1).split('');
    for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
      o = _ref3[_m];
      options[optionMap[o]] = true;
    }
  } else if (match = reLongOption.exec(arg)) {
    options[optionMap[match[2]]] = match[1] != null ? false : true;
  } else if (match = (_ref4 = reShortParameter.exec(arg)) != null ? _ref4 : reLongParameter.exec(arg)) {
    options[optionMap[match[1]]] = args.shift();
  } else {
    positionalArgs.push(arg);
  }
}

if (!(options.compile || options.jsast || options.parse || options["eval"])) {
  if (positionalArgs.length) {
    options["eval"] = true;
    options.input = positionalArgs.shift();
    additionalArgs = __slice.call(positionalArgs).concat(__slice.call(additionalArgs));
  } else {
    options.repl = true;
  }
}

if (1 !== options.compile + options["eval"] + options.jsast + options.parse + options.repl) {
  console.error('Error: At most one of --compile (-c), --eval (-e), --jsast (-j), --parse (-p), or --repl may be used.');
  process.exit(1);
}

if (1 < (options.input != null) + (options.watch != null) + (options.cli != null)) {
  console.error('Error: At most one of --input (-i), --watch (-w), or --cli may be used.');
  process.exit(1);
}

if (options.help) {
  $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
  $0 = path.basename($0);
  maxWidth = 85;
  wrap = function(lhsWidth, input) {
    var pad, rhsWidth, row, rows;
    rhsWidth = maxWidth - lhsWidth;
    pad = (Array(lhsWidth + 4 + 1)).join(' ');
    rows = (function() {
      var _results;
      _results = [];
      while (input.length) {
        row = input.slice(0, rhsWidth);
        input = input.slice(rhsWidth);
        _results.push(row);
      }
      return _results;
    })();
    return rows.join("\n" + pad);
  };
  formatOptions = function(opts) {
    var opt;
    opts = (function() {
      var _len5, _n, _results;
      _results = [];
      for (_n = 0, _len5 = opts.length; _n < _len5; _n++) {
        opt = opts[_n];
        switch (opt.length) {
          case 0:
            continue;
          case 1:
            _results.push("-" + opt);
            break;
          default:
            _results.push("--" + opt);
        }
      }
      return _results;
    })();
    opts.sort(function(a, b) {
      return a.length - b.length;
    });
    return opts.join(', ');
  };
  console.log("Usage:\n  " + $0 + " FILE ARG* [-- ARG*]\n  " + $0 + " OPT* [--repl] OPT*\n  " + $0 + " OPT* -{-parse,p,-jsast,j,-compile,c} OPT*\n  " + $0 + " {OPT,ARG}* -{-eval,e} {OPT,ARG}* -- ARG*\n");
  optionRows = (function() {
    var _len5, _n, _results;
    _results = [];
    for (_n = 0, _len5 = optionArguments.length; _n < _len5; _n++) {
      opt = optionArguments[_n];
      _results.push([formatOptions(opt[0]), opt[2]]);
    }
    return _results;
  })();
  parameterRows = (function() {
    var _len5, _n, _results;
    _results = [];
    for (_n = 0, _len5 = parameterArguments.length; _n < _len5; _n++) {
      opt = parameterArguments[_n];
      _results.push(["" + (formatOptions(opt[0])) + " " + opt[1], opt[2]]);
    }
    return _results;
  })();
  leftColumnWidth = foldl(0, __slice.call(optionRows).concat(__slice.call(parameterRows)), function(memo, opt) {
    return Math.max(memo, opt[0].length);
  });
  rows = __slice.call(optionRows).concat(__slice.call(parameterRows));
  rows.sort(function(a, b) {
    a = a[0];
    b = b[0];
    if (a.slice(0, 2) === '--' && b.slice(0, 2) !== '--') {
      return 1;
    }
    if (b.slice(0, 2) === '--' && a.slice(0, 2) !== '--') {
      return -1;
    }
    if (a.toLowerCase() < b.toLowerCase()) {
      return -1;
    } else {
      return 1;
    }
  });
  for (_n = 0, _len5 = rows.length; _n < _len5; _n++) {
    row = rows[_n];
    console.log("  " + row[0] + ((Array(leftColumnWidth - row[0].length + 1)).join(' ')) + "  " + (wrap(leftColumnWidth, row[1])));
  }
  console.log("\nUnless instructed otherwise (--{input,watch,cli}), `" + $0 + "` will operate on stdin/stdout.\nWhen none of -{-parse,p,-jsast,j,-compile,c,-eval,e,-repl} are given\n  If positional arguments were given\n    * --eval is implied\n    * the first positional argument is used as an input filename\n    * additional positional arguments are passed as arguments to the script\n  Else --repl is implied");
} else if (options.version) {
  filename = path.join(__dirname, '..', '..', 'package.json');
  fs.readFile(filename, function(err, pkg) {
    if (err) {
      throw err;
    }
    return console.log("CoffeeScript version " + (JSON.parse(pkg)).version);
  });
} else if (options.repl) {
  console.log('TODO: REPL');
} else {
  input = '';
  processInput = function(err) {
    var optimiser, result;
    if (err != null) {
      throw err;
    }
    result = null;
    try {
      input = Preprocessor.processSync(input);
    } catch (e) {
      console.error(e.stack || e.message);
      process.exit(1);
    }
    if (options.debug) {
      console.error('### PREPROCESSED ###');
      console.error(numberLines(humanReadable(input.trim())));
    }
    try {
      result = parser.parse(input);
    } catch (e) {
      if (!(e instanceof parser.SyntaxError)) {
        throw e;
      }
      printParserError(e);
      process.exit(1);
    }
    if (options.debug && (result != null)) {
      console.error('### PARSED ###');
      console.error(inspect(result.toJSON()));
    }
    if (options.optimise && (result != null)) {
      optimiser = new Optimiser;
      try {
        result = optimiser.optimise(result);
      } catch (e) {
        console.error(e.stack || e.message);
        process.exit(1);
      }
    }
    if (options.parse) {
      if (result != null) {
        console.log(inspect(result.toJSON()));
        return process.exit(0);
      } else {
        return process.exit(1);
      }
    } else if (options.optimise && options.debug && (result != null)) {
      console.error('### OPTIMISED ###');
      return console.error(inspect(result.toJSON()));
    }
  };
  if (options.input != null) {
    fs.readFile(options.input, function(err, contents) {
      if (err != null) {
        throw err;
      }
      input = contents;
      return processInput();
    });
  } else if (options.watch != null) {

  } else if (options.cli != null) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function(data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}
