// Generated by CoffeeScript 1.3.3
var Optimiser, Preprocessor, additionalArgs, arg, args, cleanMarkers, concat, filename, fs, humanReadable, input, inspect, longOptionArguments, longParameterArguments, match, numberLines, o, optionArguments, optionMap, options, opts, parameterArguments, parser, positionalArguments, printParserError, processInput, reLongOption, reLongParameter, reShortOptions, reShortOptionsShortParameter, reShortParameter, shortOptionArguments, shortParameterArguments, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

concat = require('./functional-helpers').concat;

Preprocessor = require('./preprocessor').Preprocessor;

Optimiser = require('./optimiser').Optimiser;

parser = require('./parser');

inspect = function(o) {
  return (require('util')).inspect(o, false, 9e9, true);
};

cleanMarkers = function(str) {
  return str.replace(/\uEFEF|\uEFFE\uEFFF/g, '');
};

humanReadable = function(str) {
  return (str.replace(/\uEFEF/g, '(INDENT)')).replace(/\uEFFE\uEFFF/g, '(DEDENT)');
};

numberLines = function(input, startLine) {
  var currLine, i, line, lines, numbered, pad, padSize;
  if (startLine == null) {
    startLine = 1;
  }
  lines = input.split('\n');
  padSize = ((lines.length + startLine - 1).toString(10)).length;
  numbered = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      currLine = "" + (i + startLine);
      pad = (Array(padSize + 1).join('0')).slice(currLine.length);
      _results.push("" + pad + currLine + " : " + lines[i]);
    }
    return _results;
  })();
  return numbered.join('\n');
};

printParserError = function(e) {
  var line;
  if (e.found != null) {
    line = (input.split('\n'))[e.line - 1];
    e.column = (cleanMarkers(("" + line + "\n").slice(0, e.column))).length;
  }
  console.error(humanReadable("Syntax error on line " + e.line + ", column " + e.column + ": unexpected " + (e.found != null ? inspect(e.found) : 'end of input')));
  if (e.found != null) {
    console.error(cleanMarkers(line));
    return console.error("" + ((Array(e.column)).join('-')) + "^");
  }
};

args = process.argv.slice(1 + (process.argv[0] === 'node'));

additionalArgs = [];

if (__indexOf.call(args, '--') >= 0) {
  additionalArgs = args.splice(args.indexOf('--'), 9e9);
}

options = {};

optionMap = {};

optionArguments = [[['bare', 'b'], false, 'omit the top-level function wrapper'], [['compile', 'c'], false, 'compile to JavaScript'], [['eval', 'e'], false, 'evaluate compiled javascript'], [['parse', 'p'], false, 'output a JSON-serialised AST representation of the input'], [['ast', 'a'], false, 'output a JSON-serialised AST representation of the output'], [['lint', 'l'], false, 'pass compiled javascript output through JavaScriptLint'], [['minify', 'm'], false, 'run compiled javascript output through a JS minifier'], [['repl'], false, 'run an interactive CoffeeScript REPL'], [['help'], false, 'display this help message'], [['optimise'], true, 'enable optimisations (default: on)'], [['version', 'v'], false, 'display the version number']];

parameterArguments = [[['cli'], null, 'pass a string from the command line as input'], [['input', 'i'], null, 'file to be used as input instead of STDIN'], [['nodejs'], null, 'pass options through to the node binary'], [['output', 'o'], null, 'file to be used as output instead of STDIN'], [['require', 'I'], null, 'require a library before a script is executed'], [['watch', 'w'], null, 'watch the given file/directory for changes']];

shortOptionArguments = [];

longOptionArguments = [];

for (_i = 0, _len = optionArguments.length; _i < _len; _i++) {
  opts = optionArguments[_i];
  options[opts[0][0]] = opts[1];
  _ref = opts[0];
  for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
    o = _ref[_j];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortOptionArguments.push(o);
    } else if (o.length > 1) {
      longOptionArguments.push(o);
    }
  }
}

shortParameterArguments = [];

longParameterArguments = [];

for (_k = 0, _len2 = parameterArguments.length; _k < _len2; _k++) {
  opts = parameterArguments[_k];
  _ref1 = opts[0];
  for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
    o = _ref1[_l];
    optionMap[o] = opts[0][0];
    if (o.length === 1) {
      shortParameterArguments.push(o);
    } else if (o.length > 1) {
      longParameterArguments.push(o);
    }
  }
}

reShortOptions = RegExp("^-(" + (shortOptionArguments.join('|')) + ")+$");

reLongOption = RegExp("^--(no-)?(" + (longOptionArguments.join('|')) + ")$");

reShortParameter = RegExp("^-(" + (shortParameterArguments.join('|')) + ")$");

reLongParameter = RegExp("^--(" + (longParameterArguments.join('|')) + ")$");

reShortOptionsShortParameter = RegExp("^-(" + (shortOptionArguments.join('|')) + ")+(" + (shortParameterArguments.join('|')) + ")$");

positionalArguments = [];

while (args.length) {
  arg = args.shift();
  if (reShortOptionsShortParameter.exec(arg)) {
    args.unshift("-" + arg.slice(1, -1), "-" + arg.slice(-1));
  } else if (reShortOptions.exec(arg)) {
    _ref2 = arg.slice(1).split('');
    for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
      o = _ref2[_m];
      options[optionMap[o]] = true;
    }
  } else if (match = reLongOption.exec(arg)) {
    options[optionMap[match[2]]] = match[1] != null ? false : true;
  } else if (match = (_ref3 = reShortParameter.exec(arg)) != null ? _ref3 : reLongParameter.exec(arg)) {
    options[optionMap[match[1]]] = args.shift();
  } else {
    positionalArguments.push(arg);
  }
}

if (!(options.compile || options.ast || options.parse || options.repl)) {
  options["eval"] = true;
}

if (1 !== options.compile + options["eval"] + options.ast + options.parse + options.repl) {
  console.error('Error: At most one of --compile (-c), --eval (-e), --ast (-a), --parse (-p), or --repl may be used.');
  process.exit(1);
}

if (1 < (options.input != null) + (options.watch != null) + (options.cli != null)) {
  console.error('Error: At most one of --input (-i), --watch (-w), or --cli may be used.');
  process.exit(1);
}

if (options.help) {
  console.log('  Usage: coffee [options] -- [args]');
  console.log('');
  console.log('  Unless instructed otherwise, `coffee` will operate on stdin/stdout and eval its input');
} else if (options.version) {
  filename = (require('path')).join(__dirname, '..', '..', 'package.json');
  fs.readFile(filename, function(err, pkg) {
    if (err) {
      throw err;
    }
    return console.log("CoffeeScript version " + (JSON.parse(pkg)).version);
  });
} else if (options.repl) {

} else {
  input = '';
  processInput = function(err) {
    var optimiser, result;
    if (err != null) {
      throw err;
    }
    result = null;
    console.log(numberLines(input.trim()));
    try {
      input = Preprocessor.processSync(input);
    } catch (e) {
      console.error(e.stack || e.message);
      process.exit(1);
    }
    try {
      result = parser.parse(input);
    } catch (e) {
      if (!(e instanceof parser.SyntaxError)) {
        throw e;
      }
      printParserError(e);
      process.exit(1);
    }
    if (options.optimise && (result != null)) {
      optimiser = new Optimiser;
      try {
        result = optimiser.optimise(result);
      } catch (e) {
        console.error(e.stack || e.message);
        process.exit(1);
      }
    }
    if (options.parse) {
      if (result != null) {
        console.log(inspect(result.toJSON()));
        return process.exit(0);
      } else {
        return process.exit(1);
      }
    }
  };
  if (options.input != null) {
    fs.readFile(options.input, processInput);
  } else if (options.watch != null) {

  } else if (options.cli != null) {
    input = options.cli;
    processInput();
  } else {
    process.stdin.on('data', function(data) {
      return input += data;
    });
    process.stdin.on('end', processInput);
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  }
}
